---
tags:
  - Knowledge/Algorithm
created: 2025-09-20
author:
  - ln1
status: In Progress
---
## Description

给定 L,R，请计算区间 [L,R] 中素数的个数。
### Example:  
Input: 
```
2 11
```

Output: 
```
5
```
## Question Link

[P1835 素数密度 - 洛谷](https://www.luogu.com.cn/problem/P1835)
## Approach

- 埃式筛选法预处理素数
- 二分搜索分别搜索L R的序号
- R的序号减去L的序号。
但是如果直接这么做就会MLE，原因是存储了大量的素数，因此我们使用区间筛法来进行筛选。
1. **预处理小素数**  
   使用埃拉托色尼筛法求出所有小于等于 `√R` 的素数，存入 `primes` 数组。
2. **标记区间内的合数**  
   遍历每个小素数 `p`，从 `max(p*p, ceil(L/p)*p)` 开始，在区间 `[L, R]` 中标记所有 `p` 的倍数为合数（即非素数）。
3. **特判 L = 1 的情况**  
   因为 1 不是素数，若 `L == 1`，需手动将 `isPrime[0]` 设为 `false`。
4. **统计素数个数**  
   遍历布尔数组 `isPrime`，统计其中为 `true` 的元素数量，即为区间内的素数个数。
## Implementation
V-1:

```cpp 
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> getPrimes(int limit) {
    vector<bool> isPrime(limit + 1, true);
    vector<int> primes;
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i <= limit; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = i * 2; j <= limit; j += i)
                isPrime[j] = false;
        }
    }
    return primes;
}

int main() {
    int L, R;
    cin >> L >> R;

    vector<int> primes = getPrimes(R); // 筛到 R
    auto left = lower_bound(primes.begin(), primes.end(), L);
    auto right = upper_bound(primes.begin(), primes.end(), R);

    cout << right - left << endl;
    return 0;
}

```
V-2:
```cpp
#include <cmath>
#include <iostream>
#include <vector>

using namespace std;

typedef long long ll;

vector<int> getPrimes(int limit) {
  vector<bool> isPrime(limit + 1, true);
  vector<int> primes;
  isPrime[0] = isPrime[1] = false;
  for (int i = 2; i <= limit; i++) {
    if (isPrime[i]) {
      primes.push_back(i);
      for (int j = i * 2; j <= limit; j += i)
        isPrime[j] = false;
    }
  }
  return primes;
}

int countPrimesInRange(ll L, ll R) {
  int size = R - L + 1;
  vector<bool> isPrime(size, true);

  // Step 1: Get primes up to sqrt(R)
  vector<int> primes = getPrimes(sqrt(R) + 1);

  // Step 2: Use these primes to mark non-primes in [L,R]
  for (int p : primes) {
    ll start = max(ll(p * p), ((L + p - 1) / p) * p);
    for (ll j = start; j <= R; j += p) {
      isPrime[j - L] = false;
    }
  }

  // Step 3: Handle special case when L == 1
  if (L == 1)
    isPrime[0] = false;

  // Step 4:Count primes
  int count = 0;
  for (bool val : isPrime)
    if (val)
      count++;

  return count;
}

int main() {
  ll L, R;
  cin >> L >> R;
  cout << countPrimesInRange(L, R) << endl;
  return 0;
}

```
## Analysis
## 区间筛法（Segmented Sieve）简介

区间筛法是一种用于在给定区间 `[L, R]` 中找出所有素数的高效算法，特别适用于 `R` 很大但区间长度较小的情况（如 `R - L ≤ 10^6`）。

### 原理
1. **预处理小素数**：使用埃拉托色尼筛法找出所有小于等于 `√R` 的素数。
2. **标记合数**：用这些小素数去标记区间 `[L, R]` 中的合数（即不是素数的数）。
3. **统计素数**：未被标记的数即为区间内的素数。

### 优势
- **节省空间**：只需处理长度为 `R - L + 1` 的布尔数组。
- **适用于大区间**：可处理 `L` 和 `R` 非常大的情况（如 `10^12`）。
- **高效可靠**：时间复杂度约为 `O(√R + (R - L))`，适合评测环境。

### 应用场景
- 区间素数统计
- 大数范围下的素数查询
- 竞赛题如洛谷 P1835「素数密度」

有关素数/质数的内容：
[[P3383-模板-线性筛素数]]
[[P2651-添加括号III]]
