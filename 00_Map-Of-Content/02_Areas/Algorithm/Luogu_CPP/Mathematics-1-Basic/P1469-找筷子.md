---
tags:
  - Knowledge/Algorithm
  - Knowledge/Programming-Language/cpp
  - Knowledge/Algorithm/Bitwise-Operations
  - Knowledge/Algorithm/Hashing
created: 2025-08-08
author:
  - ln1
status: Done
---
## Description

给定 n 根筷子的长度（n 为奇数），其中只有一根筷子没有配对，其他筷子都有长度相同的伙伴。请找出这根落单筷子的长度。
### Example:  
Input: 
```
9
2 2 1 3 3 3 2 3 1
```

Output: 
```
2
```
## Question Link

[P1469 找筷子-洛谷](https://www.luogu.com.cn/problem/P1469)
## Approach

- 这个题我首先想到的是用哈希表来减少搜索范围，但是因为题目限制内存为4MB，所以MLE了
```cpp 
#include <iostream>
#include <unordered_map>
#include <vector>
#define MOD 99991
using namespace std;

int n;
vector<int> hashMap[MOD];
int main() {
  cin >> n;
  while (n--) { // 首先我们将数字填入桶中
    int temp;
    cin >> temp;
    hashMap[temp % MOD].push_back(temp);
  }

  for (int i = 0; i < MOD; i++) { // 对桶进行遍历，首先寻找数量为奇数的映射
    if (hashMap[i].size() % 2 != 0) {
      unordered_map<int, int> cnt; // 定义一个map来统计数字出现了多少次
      for (auto x : hashMap[i]) {
        cnt[x]++;
      }
      for (auto &p : cnt) { // 寻找筷子出现次数为奇数的筷子
        if (p.second % 2 != 0) {
          cout << p.first << endl;
          return 0;
        }
      }
    }
  }
  return 0;
}
```

- 然后考虑到可以不用unordered_map，直接使用计数，改变桶内的记数方法，然后还是不可以通过，最终想了下，发现无论如何调整10^7都会超出内存。int是4个字节，4\*10^7  = 40MB,无论如何都无法满足条件。
```cpp
 for (int i = 0; i < MOD; i++) { // 对桶进行遍历，首先寻找数量为奇数的映射
    if (hashMap[i].size() % 2 != 0) {
      int cnt = 1;
      sort(hashMap[i].begin(),
           hashMap[i].end()); // 首先对其进行排序,这样就方便统计连续的数字个数了
      for (size_t j = 1; j <= hashMap[i].size(); j++) {
        if (hashMap[i][j] ==
            hashMap[i][j - 1]) { // 如果这一个数字和前一个数字相同则计数+1
          cnt++;
        } else { // 不相同则检查是否是奇数
          if (cnt % 2 != 0) {
            cout << hashMap[i][j - 1] << endl;
            return 0;
          }
          cnt = 1; // 是偶数则重新进入循环
        }
      }
    }

```
- 于是最终看了下题解发现只需要非常简单地使用位运算，进行异或就可以实现高效快速地寻找唯一的没有配对的筷子。
	i为什么使用异或可以解决这个问题？主要参考了以下两个性质：
	- **X\^X = 0**
	- **X\^0 = 0**
	这样配对的筷子就可以直接消去变成0，然后0与没有配对的数字进行异或则得到最终没有配对的数字。
> 另外有关位运算的CSAPP的DataLab实验，其中有部分题目使用了 `^ `  : [[Data-lab]]
## Implementation

```cpp
#include <iostream>
using namespace std;

int n;
int res;

int main() {
  ios::sync_with_stdio(false);  //关闭Cpp和C的输入输出流同步
  cin.tie(nullptr);           //取消cin绑定cout
	//上面两条必须加上,不然会超时
  cin >> n;
  int temp;
  while (n--) {
    cin >> temp;
    res ^= temp;
  }
  cout << res << endl;
  return 0;
}
```

## Analysis
### 1. 通常不在函数内部，例如main()中定义大数组，
#### 原因：

- **栈空间有限**：函数内部定义的数组（如 `int arr[1000000];`）分配在栈上，栈通常只有几 MB 空间（比如默认8MB），超过会导致栈溢出（Stack Overflow）。
- **大数组容易导致程序崩溃**：超大数组会占用大量栈空间，运行时直接崩溃。

---

#### 解决方案

1. **使用动态内存分配（堆）**
	例如使用 `vector` 动态分配：
```cpp
   int n = 1000000;
   vector<int> arr(n);  // 堆分配，不占用栈空间
```
2. **将大数组定义为全局或静态变量**
	全局和静态变量存放在静态存储区，不占用栈空间：
```cpp
const int MAX = 1000000;
int arr[MAX];  // 全局变量，安全
```
### 2. 这道题必须关闭Cpp和C的输入输出流同步和cin/cout之间的绑定
#### 详细解释:
1. `ios::sync_with_stdio(false);`
	默认情况下，C++ 的标准输入输出流（`cin`/`cout`）和 C 标准库的输入输出流（`scanf`/`printf`）是同步的，目的是**保证混合使用时不会出现顺序错乱**。但是同步会带来**额外开销**，关闭同步后，`cin` 和 `cout` 会独立运行，速度会提升很多，通常可快上几倍。
2. `cin.tie(nullptr);`
	默认情况下，`cin` 绑定了 `cout`，即每次从 `cin` 读取之前，都会先刷新 `cout` 的缓冲区，保证用户先看到输出内容。在一些性能敏感的场景下，这个自动刷新会降低速度。调用 `cin.tie(nullptr)` 解绑后，`cin` 就不会自动刷新 `cout`，**减少了不必要的刷新，提高效率**。