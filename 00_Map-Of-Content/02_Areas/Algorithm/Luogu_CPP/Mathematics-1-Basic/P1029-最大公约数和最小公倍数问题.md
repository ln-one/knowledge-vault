---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
  - Knowledge/Algorithms/GCD
created: 2025-09-21
author:
  - ln1
status: Done
---
## Description

求满足最大公约数为 (x_0)、最小公倍数为 (y_0) 的正整数对 (P, Q) 的个数。
### Example:  
Input: 
```
3 60
```

Output: 
```
4
```
## Question Link

[P1029 [NOIP 2001 普及组] 最大公约数和最小公倍数问题 - 洛谷](https://www.luogu.com.cn/problem/P1029)
## Approach

- 关键在于两个数的积等于它们最大公约数和它们最小公倍数的积
- 辗转相除法：
![[Pasted image 20250921181123.png]]

## Implementation

```cpp
#include <iostream>
#include <cmath>
#include <numeric> // for std::gcd

using namespace std;

int main() {
  long long g, l;
  cin >> g >> l;

  if (l % g != 0) {
    cout << 0;
    return 0;
  }

  long long x = g * l;
  long long ans = 0;

  for (long long i = 1; i <= sqrt(x); ++i) {
    if (x % i == 0) {
      long long j = x / i;
      if (std::gcd(i, j) == g) {
        ans += (i == j) ? 1 : 2;
      }
    }
  }

  cout << ans;
  return 0;
}
```

## Analysis
- **核心公式**  
  `gcd(a, b) * lcm(a, b) = a * b`

- **建模技巧**  
  设 `a = x * m`, `b = x * n`  
  条件转化为：
  - `m * n = y / x`
  - `gcd(m, n) = 1`

- **枚举方法**  
  枚举所有满足 `m * n = y / x` 且互质的因数对 `(m, n)`。

- **边界处理**  
  - 若 `y % x != 0` → 无解  
  - 若 `x == y` → 注意避免重复计数

- **算法应用**  
  - 欧几里得算法求 GCD  
  - 枚举至 `sqrt(k)` 提高效率