---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithm/Bitwise-Operations
created: 2025-08-19
author:
  - ln1
status: Done
---
## Description
设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。
### Example:  
Input: 
```
30000 -2
```

Output: 
```
30000=11011010101110000(base-2)
```
## Question Link

[P1017 [NOIP 2000 提高组] 进制转换](https://www.luogu.com.cn/problem/P1017)
## Approach
- 这道题目的关键在于让转换成一个**负进制**的数，不同于我们平常见到的`2 4 8 16`等*正进制*；
- 那么我们还是按照原先的思路将数字挨个除于进制取余是否是可行的呢？
	- 那么又会引出另一个问题：==在C++中负数除负数，余数会是负数==；
所以关键就在于如何把这个负数转换成正数：
1. 首先分析目前已知的最基本的规则`被除数 = 商 * 除数 + 余数`
2. 我们已知==除数一定大于余数==，那么我们将为负数的余数-除数(__此处除数为负数，所以要减去__)，变可以将其变为正数；
3. 但仅仅这样还不算完，因为额外加上了一个除数，于是商便要 +1
`（商+1）*除数+（余数-除数）=商*除数+除数+余数-除数=商*除数+余数=被除数`
## Implementation

```cpp
#include <iostream>
#include <stack>

using namespace std;

char int_to_char(int x) {
  if (x <= 9) {
    return x + '0';
  } else {
    return x - 10 + 'A';
  }
}

void decimal_to_m(long long decimal_val, int m) {
  stack<int> st;
  long long origin_dec = decimal_val;
  while (decimal_val != 0) {
    int temp = decimal_val % m;
    if (temp < 0) {
      temp -= m;
      decimal_val = (decimal_val / m) + 1;
    } else {
      decimal_val = decimal_val / m;
    }
    st.push(temp);
  }
  cout << origin_dec << '=';
  while (!st.empty()) {
    cout << int_to_char(st.top());
    st.pop();
  }
  cout << "(base" << m << ")";
  cout << endl;
}

int main() {
  long long n;
  int m;
  cin >> n >> m;
  decimal_to_m(n, m);
  return 0;
}
```

## Analysis
---
1. **正数 % 正数**
    - `a > 0, b > 0`
    - 结果一定是 **非负**（`0 ≤ a % b < b`）
    - 例：`7 % 3 = 1`
---
2. **正数 % 负数**
    - `a > 0, b < 0`
    - 结果仍然是 **非负**（符号随 `a`，和 `b` 无关）
    - 例：`7 % -3 = 1`
---
3. **负数 % 正数**
    - `a < 0, b > 0`
    - 结果一定是 **非正**（`-(b-1) ≤ a % b ≤ 0`）
    - 例：`-7 % 3 = -1`
---
4. **负数 % 负数**
    - `a < 0, b < 0`
    - 结果仍然是 **非正**（符号随 `a`）
    - 例：`-7 % -3 = -1`
#### 总结：C++中余数的符号是由被除数决定的，如果被除数是负数，则余数为负，反之同理。