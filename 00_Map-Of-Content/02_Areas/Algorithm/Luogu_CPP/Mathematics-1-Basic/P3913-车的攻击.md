---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
created: 2025-09-15
author:
  - ln1
status: Done
---
## Description

N×N 的国际象棋棋盘上有K 个车，第i个车位于第Ri​行，第Ci​ 列。求至少被一个车攻击的格子数量。求车可以攻击所有同一行或者同一列的地方。
### Example:  
Input: 
```
3 2
1 2
2 2
```

Output: 
```
7
```
## Question Link

[P3913 车的攻击 - 洛谷](https://www.luogu.com.cn/problem/P3913)
## Approach

- 我首先想到的是使用集合去重，然后统计出已知的被占用的行和列的号码，然后进行后续的分析：
	1. 结果+=占用行数\*N；
	2. 结果+=占用列数*(N-占用行数)；
## Implementation

```cpp
#include <iostream>
#include <unordered_set>

using namespace std;

long long n, k;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  cin >> n >> k;
  unordered_set<int> r;
  unordered_set<int> c;

  int temp_r, temp_c;
  while (k--) {
    cin >> temp_r >> temp_c;
    r.insert(temp_r);
    c.insert(temp_c);
  }
  long long rowNum = r.size();
  long long colNum = c.size();

  long long ans = rowNum * n + colNum * (n - rowNum);

  cout << ans << endl;

  return 0;
}
```

## Analysis
### 一开始不能完全通过：
原因：ans变量选择的是int，导致在部分条件下，数据溢出了，换为long long后正常。