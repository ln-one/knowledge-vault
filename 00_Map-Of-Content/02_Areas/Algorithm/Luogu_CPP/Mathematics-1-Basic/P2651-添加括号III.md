---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
created: 2025-09-27
author:
  - ln1
status: Done
---
## Description
给定若干形如 $a_1/a_2/\dots/a_n$ 的除法表达式，判断是否存在加括号改变运算顺序能使表达式结果为整数，对每个表达式输出 Yes 或 No。

### Example:  
Input: 
```
2
4
1 2 1 4
5
6 5 7 9 12
```

Output: 
```
Yes
No
```
## Question Link
[P2651 添加括号III-洛谷](https://www.luogu.com.cn/problem/P2651)
## Approach

- 括号的本质是什么？
	- 比如 $a_1 / a_2 / a_3$ ，你可以通过加括号把它变成 $(a_1/a_2) / a_3$ 或者 $a_1 / (a_2/a_3)$，对应的结果会是$\frac{a_1}{a_2a_3}$或者 $\frac{a_1a_3}{a_2}$。
	- 因此加括号的本质是在有一定约束条件的情况下决定哪些数是放在分子，那些数字又是放在分母。
- 思考其数学性质，考虑到要使得分数A/B为整数所需要的条件。
	- 就是分子可以被分母整除。
- 综合得到题目本质：能不能找到一种分组，使得分母的乘积能被分子整除或者说分子能包含分母的所有质因子。
- 然后探究这个约束条件:$a_1$肯定是分子，$a_2$肯定是分母，后面的随便放，那么我们如何让分子尽可能包含分母的质因子呢：
	- $a_1/(a_2/a_3/a_4\dots$) = $\frac{a_1a_3a_4\dots}{a_2}$;
- 显然，如果以上这个式子的分子不能包含分母的所有质因子或者说分子不能被分母整除，那么一定不存在其它任何情况能够达到我们的要求。
- 我们既然确定了这一点，为了避免直接在开始就将所有的数全部相乘，我们考虑，从$a_1$开始，每为分子乘一个数就进行一次判断，直到最后所有相乘都不能满足要求则判断为不符号条件。但是存在一个问题，大量数值相乘会导致溢出。
- 因此我们使用质因子分解的方式来解决这个问题：最终判断分子的质因子的指数是否全部覆盖了分母的质因子。
```cpp
// 将一个数分解质因子，并把结果加到 map 中
// sign = +1 表示分子，-1 表示分母
void factorize(long long x, int sign, unordered_map<int, int>& mp) {
    for (long long p = 2; p * p <= x; ++p) {
        while (x % p == 0) {
            mp[(int)p] += sign;
            x /= p;
        }
    }
    if (x > 1) mp[(int)x] += sign;
}
```


## Implementation

```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

// 分解质因数，sign = +1 表示分子，-1 表示分母
void factorize(long long x, int sign, unordered_map<int, int> &mp) {
  for (long long p = 2; p * p <= x; ++p) {
    while (x % p == 0) {
      mp[(int)p] += sign;
      x /= p;
    }
  }
  if (x > 1)
    mp[(int)x] += sign;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t;
  cin >> t;
  while (t--) {
    int n;
    cin >> n;

    unordered_map<int, int> mp;

    for (int i = 0; i < n; i++) {
      long long temp;
      cin >> temp;
      int sign = (i == 1) ? -1 : 1; // a2在分母，其余在分子
      factorize(temp, sign, mp);
    }

    bool ok = true;
    for (auto &kv : mp) {
      if (kv.second < 0) { // 分母质因子指数大于分子
        ok = false;
        break;
      }
    }

    cout << (ok ? "Yes" : "No") << "\n";
  }
  return 0;
}
```

## Analysis
## Knowledge Points

1. **运算顺序与括号本质**  
   - 括号改变的是计算顺序，本质是决定哪些数在分子、哪些数在分母。  
   - 对除法链式表达式 $a_1 / a_2 / \dots / a_n$，任意加括号可转化为 $(\prod \text{分子}) / (\prod \text{分母})$。

2. **整除性条件**  
   - 表达式结果为整数的条件是：**分母的质因子指数必须小于等于分子的质因子指数**。  
   - 仅需比较质因子指数，而不必计算大整数乘积。

1. **质因子分解法**  （质数就是素数）
   - 用质因子分解来维护分子和分母的质因子指数差，避免整数溢出。  
   - 分子指数加，分母指数减，最终检查所有质因子指数是否非负。

4. **优化策略**  
   - 固定 $a_1$ 在分子、$a_2$ 在分母，剩余数尽量放分子，以增强分子整除能力。  
   - 如果最大化分子仍无法整除分母，则无任何括号组合可行。

5. **数学性质与判断技巧**  
   - 整除性判断可仅依赖质因子指数，不依赖数值乘积大小。  
   - 该方法可推广到任意乘除组合问题，核心是分子能覆盖分母的质因子。

6. **复杂度控制**  
   - 每个数最多分解到 $\sqrt{a_i}$ 次。  
   - 使用 map 或数组维护质因子指数，避免大整数计算和溢出问题。

[[P1835-素数密度]]
[[P3383-模板-线性筛素数]]
