---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
created: 2025-09-17
author:
  - ln1
status: In Progress
---
## Description

判断一个由升序小写字母组成、长度不超过6的单词在所有符合条件的单词按字典序排列中的位置编号，不合法则输出 0
### Example:  
Input: 
```
ab
```

Output: 
```
27
```
## Question Link

[P1246 编码 - 洛谷](https://www.luogu.com.cn/problem/P1246)
## Approach

- 因为题目中明确了字母必须按照升序排列，所以如果我给到{a,b,c}三个字母，那么有且仅有一种表现形式abc。因此单词编码和对应字母集合的的关系是一一对应的。
- 那么这个问题我们可以考虑，如果给出一个单词`cfh`，
	1. 那么它肯定比一个字母的大，因此ans+=26
	2. 又肯定比两个字母的大，因此ans+=C(2,26)；
	3. 
		1. 又肯定比a开头的三个字母的大，ans+=C(2,25)；
		2. 比b开头的三个字母大，ans+=C(2,24)；
		3. 
			1. 接下来比cd开头的三个字母大,ans+=22;
			2. 比ce开头的三个字母大,ans+=21;
			3. 接下来到cf:
				1. cfh前面有一个cfg。ans+=1
那么最后再给ans++。即得到结果，从中我们看到主要的最后一层比较关键，从中提取出最关键的部分：
	每次检查一个字母，首先判断它是不是这一个单词中最后一个字母，如果不是，记录单词这一位后面还有几位，计为`remainNum`。那么接下来一个从a字母开始的for循环，直到碰到单词相对应的字母：
		那么我for循环选定了一个字母，我要判断这个字母是在26个字母中后面还剩多少个字母`letterNum`。那么我们ans+=C(remainNum,letterNum)。
		其中C的计算公式为：
```cpp
int c(int m,int n)
{
	if(m==0)return 1;
	int mut=1;
	for(int i=n;i>n-m;i--)mut*=i;
	for(int i=m;i>1;i--)mut/=i;
	return mut;
}
```



## Implementation

```cpp
#include <iostream>
#include <string>

using namespace std;

const int MAXN = 30;
int comb[MAXN][MAXN];

void init_comb(int maxn) {
  for (int i = 0; i <= maxn; i++) {
    comb[i][0] = comb[i][i] = 1;
    for (int j = 1; j < i; j++) {
      comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];
    }
  }
}

int get_code(const string &s) {
  int n = s.size(), ans = 0;

  // check if legal
  for (int i = 1; i < n; i++) {
    if (s[i] <= s[i - 1])
      return 0;
  }

  // 1.add the combNum of word which length less than
  for (int i = 1; i < n; i++) {
    ans += comb[26][i];
  }

  // 2.emum every letter,calculate combNum before it
  for (int i = 0; i < n; i++) {
    char start = (i == 0) ? 'a' : s[i - 1] + 1;
    for (char ch = start; ch < s[i]; ch++) {
      int remain = n - i - 1;
      int available = 'z' - ch;
      ans += comb[available][remain];
    }
  }

  // 3.add itself
  return ans + 1;
}

int main() {
  string s;
  cin >> s;
  init_comb(26);
  cout << get_code(s) << endl;
  return 0;
}

```

## Analysis

这道题偏模拟，然后仍旧是利用了杨辉三角的预处理`init_comb()`，看来还是很重要的。
杨辉三角参见：
[[P2638-安全系统]]
[[P2822-组合数问题]]

