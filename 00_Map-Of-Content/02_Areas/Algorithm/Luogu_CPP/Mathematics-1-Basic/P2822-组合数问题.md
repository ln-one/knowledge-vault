---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
created: 2025-09-09
author:
  - ln1
status: Done
---
## Description
![[Pasted image 20250909223925.png]]
### Example:  
Input: 
```
1 2
3 3
```

Output: 
```
1
```
## Question Link

[P2822 [NOIP 2016 提高组] 组合数问题 - 洛谷](https://www.luogu.com.cn/problem/P2822)
## Approach
- 那么我们分析这个题目，既然是要求阶乘，又因为数值范围较大，所以我们使用杨辉三角来预处理记忆化改进。
![[Pasted image 20250909224531.png]]
- 然后就是计算二维前缀和，分析三种情况：
	1. 若x = 0且y = 0：`prefix[i][j] = isDivisible;`
	2. 若x != 0但 y = 0：`prefix[i][j] = prefix[i - 1][j] + isDivisible;`
	3. 其它，当这个其它的时候：`prefix[i][j] = prefix[i][j - 1] + prefix[i - 1][j]  - prefix[i - 1][j - 1]  + isDivisible;`
固定预处理之后，以后直接查询相对应的值就十分方便了。
## Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 2000;

int C[MAXN + 1][MAXN + 1]; // Store C(i,j) mod k
int prefix[MAXN + 1][MAXN + 1];
int t, k;

void init() {
  for (int i = 0; i <= MAXN; i++) {
    for (int j = 0; j <= i; j++) {
      if (j == 0 || i == j) {
        C[i][j] = 1 % k;
      } else {
        C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;
      }

      // check isDivisible by k;
      int isDivisible = (C[i][j] == 0);

      // prefix
      if (i == 0 && j == 0) {
        prefix[i][j] = isDivisible;
      } else if (j == 0) {
        prefix[i][j] = prefix[i - 1][j] + isDivisible;
      } else {
        prefix[i][j] = prefix[i][j - 1] + prefix[i - 1][j] -
                       prefix[i - 1][j - 1] + isDivisible;
      }
    }
    for (int j = i + 1; j <= MAXN; j++) {
      prefix[i][j] = prefix[i][i];
    }
  }
}
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  cin >> t >> k;

  init();

  while (t--) {
    int n, m;
    cin >> n >> m;
    cout << prefix[n][min(m, n)] << endl;
  }
  return 0;
}

```

## Analysis
**关键在于杨辉三角预处理的思路**