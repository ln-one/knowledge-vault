---
tags:
  - Knowledge/Algorithm
  - Knowledge/Algorithms/Math
created: 2025-09-19
author:
  - ln1
status: Done
---
## Description
查询第 k 小的素数。
### Example:  
Input: 
```
100 5
1
2
3
4
5
```

Output: 
```
2
3
5
7
11
```
## Question Link

[P3383 【模板】线性筛素数 - 洛谷](https://www.luogu.com.cn/problem/P3383)
## Approach

- 显然如果是一个一个判断一个数是否是素数的话，那么时间复杂度过高。
- 我们采取记忆化的思路：先快速确定好哪些数字是素数将其记忆，然后后续再取用
- 采用**埃式筛选法**：
	1. 排除不是素数的数，剩下的就都是素数。
	2. 首先假定所有的数全是素数
	3. 0，1不是素数，然后接下来从2开始，判断是否是素数，如果是素数，那么从这个素数开始
		1. 假定x是素数，那么2\*x 3\*x......都不是素数，然后标记。
	4. 直到`i*i<=n`
- 然后我们对素数进行排序，存进一个新的vector数组
- 接下来之间访问数组中第k个元素即可。


## Implementation

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 1e8 + 5;

int n, q;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  
  cin >> n >> q;
  vector<bool> isPrime(n + 1, true);
  isPrime[0] = isPrime[1] = false;
  for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
      for (int j = i * i; j <= n; j += i) {
        isPrime[j] = false;
      }
    }
  }

  vector<int> primes;
  for (int i = 2; i <= n; i++) {
    if (isPrime[i]) {
      primes.push_back(i);
    }
  }

  while (q--) {
    int k;
    cin >> k;
    cout << primes[k - 1] << "\n";
  }
  return 0;
}

```

## Analysis

**埃氏筛法**（Sieve of Eratosthenes）是一种用于找出一定范围内所有素数的高效算法。它的基本思想是**从小到大逐步筛去合数**，剩下的就是素数。这个方法是最早且最经典的素数筛选算法之一。

### 基本步骤：

1. **初始化：**
    
    - 假设所有数（从 2 到 `n`）都是素数。用一个布尔数组 `isPrime` 来表示每个数是否是素数，初始化为 `true`。
        
    - 设置 `isPrime[0] = false` 和 `isPrime[1] = false`，因为 `0` 和 `1` 不是素数。
        
2. **筛选过程：**
    
    - 从 `i = 2` 开始，遍历到 `sqrt(n)`：
        
        - 如果 `i` 是素数（`isPrime[i] == true`），那么它的所有倍数（从 `i * i` 开始，步长为 `i`）都是合数，标记为 `false`。
            
        - 继续检查下一个数。
            
3. **停止条件：**
    
    - 当 `i * i > n` 时，停止筛选，因为更大的倍数已经被更小的素数处理过了。
        
4. **结果：**
    
    - 最终，所有 `isPrime[i] == true` 的 `i` 就是素数。

链接：
[[P1835-素数密度]]
[[P2651-添加括号III]]