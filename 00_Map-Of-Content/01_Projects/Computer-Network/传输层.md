---
tags:
  - Knowledge/Computer-Network
created: 2025-12-15
author:
  - ln1
status: In Progress
---
## 1. 传输层概述
### 1.1 传输层的位置与功能
传输层位于应用层和网络层之间，为应用程序提供**进程到进程**的通信服务。

**网络层 vs 传输层：**

| 层次 | 服务对象 | 类比 |
|-----|---------|------|
| 网络层 | 主机到主机 | 邮政系统（门到门） |
| 传输层 | 进程到进程 | 家庭成员收发信件（人到人） |

> 网络层把数据送到目的主机，传输层把数据交给正确的进程

**传输层的核心功能：**
- **复用**：从多个套接字收集数据，交给网络层发送
- **分用**：将网络层收到的数据，交付给正确的套接字
- **差错检测**：检测报文是否出错

### 1.2 Internet传输层协议
| 协议 | 特点 | 适用场景 |
|-----|------|---------|
| UDP | 无连接、不可靠、简单快速 | DNS、流媒体、游戏 |
| TCP | 面向连接、可靠、有序 | Web、邮件、文件传输 |

> UDP像寄明信片（快但不保证送达），TCP像打电话（先建立连接，保证通话质量）


## 2. 套接字与端口号
### 2.1 套接字（Socket）
**套接字**是应用层和传输层之间的接口，是应用程序和网络之间的"门"。

**进程标识 = 主机IP地址 + 端口号**

### 2.2 端口号
**端口号**：16位数字（0~65535），用于区分同一主机上的不同进程

| 端口范围 | 名称 | 用途 |
|---------|------|------|
| 0~1023 | 熟知端口 | 系统服务（HTTP=80, FTP=21） |
| 1024~49151 | 注册端口 | 需要向IANA注册 |
| 49152~65535 | 动态端口 | 客户端临时使用 |

**常用端口号（必背）：**

| 端口 | 协议/服务 |
|-----|----------|
| 20/21 | FTP（数据/控制） |
| 22 | SSH |
| 23 | Telnet |
| 25 | SMTP |
| 53 | DNS |
| 80 | HTTP |
| 110 | POP3 |
| 143 | IMAP |
| 443 | HTTPS |

### 2.3 复用与分用
![[Pasted image 20251230190537.png]]
**UDP分用**：使用二元组 `<目的IP, 目的端口>` 标识套接字
- 相同目的IP和端口的报文送到同一个套接字

**TCP分用**：使用四元组 `<源IP, 目的IP, 源端口, 目的端口>` 标识连接套接字
- 服务器可以同时服务多个客户端

> UDP用"地址+门牌号"找人，TCP用"完整的双方信息"建立专线


## 3. UDP协议
### 3.1 UDP特点
- **无连接**：发送前不需要建立连接
- **不可靠**：不保证交付、不保证顺序
- **简单**：首部开销小（8字节）
- **快速**：无拥塞控制，可以尽快发送

### 3.2 UDP报文格式
```
 0      15 16     31
+--------+--------+
| 源端口  | 目的端口 |  ← 各16位
+--------+--------+
| 长度    | 校验和  |  ← 各16位
+--------+--------+
|      数据       |
+----------------+
```

**字段说明：**
- **源端口**：发送方端口号
- **目的端口**：接收方端口号
- **长度**：UDP报文总长度（首部+数据）
- **校验和**：检测报文是否出错（可选）

### 3.3 UDP校验和计算
校验和计算包括三部分：
1. **伪首部**：源IP、目的IP、协议号、UDP长度
2. **UDP首部**
3. **数据**

> 伪首部的作用：防止IP地址错误导致的误投递

**计算方法：**
- 将报文看成16位整数序列
- 求和（进位回卷）
- 取反码作为校验和

### 3.4 UDP适用场景
- 容忍丢包但对延迟敏感：流媒体、实时游戏
- 单次请求/响应：DNS查询
- 广播/组播应用


## 4. TCP协议
### 4.1 TCP特点
- **面向连接**：通信前需要三次握手建立连接
- **可靠传输**：保证数据正确、有序到达
- **全双工**：双向同时传输
- **字节流**：不保留报文边界
- **流量控制**：防止接收方缓存溢出
- **拥塞控制**：防止网络过载

### 4.2 TCP报文段格式
```
 0                   15 16                  31
+---------------------+---------------------+
|      源端口(16)      |     目的端口(16)     |
+---------------------+---------------------+
|              序号 Seq (32位)               |
+-------------------------------------------+
|            确认号 Ack (32位)               |
+----+------+--------+---------------------+
|首部|保留  |标志位   |    窗口大小(16)      |
|长度|      |UAPRSF  |                     |
+----+------+--------+---------------------+
|     校验和(16)      |    紧急指针(16)      |
+---------------------+---------------------+
|           选项（可变长度）                  |
+-------------------------------------------+
|              数据                         |
+-------------------------------------------+
```

**重要字段：**

| 字段 | 长度 | 作用 |
|-----|------|-----|
| 序号(Seq) | 32位 | 数据第一个字节的序号 |
| 确认号(Ack) | 32位 | 期望收到的下一个字节序号 |
| 首部长度 | 4位 | TCP首部长度（以4字节为单位） |
| 窗口大小 | 16位 | 接收方可接收的字节数 |

**标志位（需要记忆）：**

| 标志 | 含义 |
|-----|------|
| SYN | 同步，用于建立连接 |
| ACK | 确认，确认号有效 |
| FIN | 结束，用于释放连接 |
| RST | 复位，重置连接 |
| PSH | 推送，立即交付数据 |
| URG | 紧急，紧急指针有效 |

> 序号是字节序号，不是报文段序号！


### 4.3 TCP连接管理
#### 三次握手（建立连接）
```
客户端                              服务器
   |                                  |
   |  ----SYN, Seq=x--------------->  |  第1次：客户端发送SYN
   |                                  |
   |  <---SYN+ACK, Seq=y, Ack=x+1---  |  第2次：服务器回复SYN+ACK
   |                                  |
   |  ----ACK, Seq=x+1, Ack=y+1--->   |  第3次：客户端发送ACK
   |                                  |
   |         连接建立完成              |
```

**为什么需要三次握手？**
- 防止已失效的连接请求到达服务器
- 双方确认对方的发送和接收能力
- 协商初始序号

> 两次握手的问题：旧的SYN可能导致服务器建立无效连接

#### 四次挥手（释放连接）
```
客户端                              服务器
   |                                  |
   |  ----FIN, Seq=u-------------->   |  第1次：客户端请求关闭
   |                                  |
   |  <---ACK, Seq=v, Ack=u+1------   |  第2次：服务器确认
   |                                  |
   |      （服务器可能还有数据要发送）   |
   |                                  |
   |  <---FIN, Seq=w, Ack=u+1------   |  第3次：服务器请求关闭
   |                                  |
   |  ----ACK, Seq=u+1, Ack=w+1--->   |  第4次：客户端确认
   |                                  |
   |    等待2MSL后关闭                 |
```

**为什么需要四次挥手？**
- TCP是全双工，每个方向需要单独关闭
- 服务器收到FIN后可能还有数据要发送

**为什么客户端要等待2MSL？**
- MSL = 最大报文段生存时间
- 确保最后的ACK能到达服务器
- 让本连接的所有报文段从网络中消失


### 4.4 TCP可靠传输
#### 可靠传输机制
| 机制 | 作用 |
|-----|------|
| 序号 | 标识每个字节，检测丢失和乱序 |
| 确认 | 告知发送方已收到的数据 |
| 重传 | 超时或收到重复ACK时重传 |
| 校验和 | 检测数据是否出错 |

#### 累积确认
- TCP使用**累积确认**：确认号表示该序号之前的所有字节都已收到
- 例：Ack=100 表示序号0~99的字节都已收到，期望收到序号100

#### 超时重传
**超时时间的设置：**
- 太小：导致不必要的重传
- 太大：丢包恢复太慢

**RTT估计（指数加权移动平均）：**
```
EstimatedRTT = (1-α) × EstimatedRTT + α × SampleRTT
（典型值：α = 0.125）

DevRTT = (1-β) × DevRTT + β × |SampleRTT - EstimatedRTT|
（典型值：β = 0.25）

TimeoutInterval = EstimatedRTT + 4 × DevRTT
```

> 不对重传的报文段测量RTT（避免二义性）

#### 快速重传
- 收到**3个重复ACK**时，立即重传丢失的报文段
- 不等待超时，加快丢包恢复

```
发送方收到：ACK=100, ACK=100, ACK=100, ACK=100
           ↑原始    ↑重复1   ↑重复2   ↑重复3
                                      ↓
                              立即重传序号100的报文段
```


### 4.5 TCP流量控制
**目的**：防止发送方发送过快，导致接收方缓存溢出

**机制：滑动窗口**
- 接收方在报文段中通告**接收窗口（rwnd）**
- 发送方限制：`已发送未确认的数据量 ≤ rwnd`

```
接收缓存：
+------------------+------------------+
|   已接收待读取    |     可用空间      |
+------------------+------------------+
                   ↑
              接收窗口 rwnd
```

**零窗口问题：**
- 当rwnd=0时，发送方停止发送
- 发送方定期发送**零窗口探测**报文
- 接收方回复当前窗口大小

**糊涂窗口综合症：**
- 问题：发送大量小报文段，效率低
- 解决：
  - 接收方：窗口足够大时才通告
  - 发送方：Nagle算法，积累数据再发送

### 4.6 TCP拥塞控制
**目的**：防止过多数据注入网络，导致网络拥塞

**拥塞控制 vs 流量控制：**

| 控制类型 | 目的      | 关注对象  |
| ---- | ------- | ----- |
| 流量控制 | 防止接收方溢出 | 接收方缓存 |
| 拥塞控制 | 防止网络拥塞  | 网络容量  |

#### 拥塞窗口（cwnd）
- 发送方维护的变量，限制发送速率
- 实际发送窗口 = min(cwnd, rwnd)

#### 拥塞控制算法
**1. 慢启动（Slow Start）**
- 初始：cwnd = 1 MSS
- 每收到一个ACK：cwnd = cwnd + 1 MSS
- 效果：cwnd指数增长（1→2→4→8...）
- 直到：cwnd ≥ ssthresh（慢启动阈值）

**2. 拥塞避免（Congestion Avoidance）**
- 当cwnd ≥ ssthresh时进入
- 每个RTT：cwnd = cwnd + 1 MSS
- 效果：cwnd线性增长

**3. 快速恢复（Fast Recovery）**
- 收到3个重复ACK时触发
- ssthresh = cwnd / 2
- cwnd = ssthresh + 3 MSS
- 继续拥塞避免


#### 拥塞控制状态转换
```
                    超时
    ┌──────────────────────────────────┐
    │                                  │
    ▼                                  │
┌────────┐  cwnd≥ssthresh  ┌──────────┐│
│ 慢启动  │───────────────→│ 拥塞避免  ││
└────────┘                 └──────────┘│
    │                          │       │
    │ 超时                     │3个重复ACK
    │ ssthresh=cwnd/2          ▼       │
    │ cwnd=1              ┌──────────┐ │
    └────────────────────→│ 快速恢复  │─┘
                          └──────────┘
                               │
                               │ 新ACK
                               ▼
                          返回拥塞避免
```

**超时处理：**
- ssthresh = cwnd / 2
- cwnd = 1 MSS
- 重新进入慢启动

**3个重复ACK处理：**
- ssthresh = cwnd / 2
- cwnd = ssthresh + 3 MSS
- 进入快速恢复

> 超时比3个重复ACK更严重，所以cwnd降得更低

## 5. TCP vs UDP 对比

| 特性 | TCP | UDP |
|-----|-----|-----|
| 连接 | 面向连接 | 无连接 |
| 可靠性 | 可靠 | 不可靠 |
| 顺序 | 保证顺序 | 不保证 |
| 流量控制 | 有 | 无 |
| 拥塞控制 | 有 | 无 |
| 首部开销 | 20字节起 | 8字节 |
| 传输方式 | 字节流 | 报文 |
| 速度 | 相对慢 | 快 |
| 适用场景 | 可靠传输 | 实时应用 |


## 6. 重点概念速记

### 关键公式
```
实际发送窗口 = min(拥塞窗口cwnd, 接收窗口rwnd)

超时时间 = EstimatedRTT + 4 × DevRTT

慢启动：每个ACK后 cwnd = cwnd + 1 MSS（指数增长）
拥塞避免：每个RTT后 cwnd = cwnd + 1 MSS（线性增长）
```

### 重要数字
| 项目 | 数值 |
|-----|------|
| TCP首部最小长度 | 20字节 |
| UDP首部长度 | 8字节 |
| 端口号范围 | 0~65535 |
| 熟知端口范围 | 0~1023 |
| 快速重传触发条件 | 3个重复ACK |
| 推迟确认最大时间 | 500ms |

### 易混淆概念
| 概念 | 说明 |
|-----|------|
| 序号 vs 确认号 | 序号是发送的第一个字节，确认号是期望收到的下一个字节 |
| 流量控制 vs 拥塞控制 | 流量控制防止接收方溢出，拥塞控制防止网络拥塞 |
| cwnd vs rwnd | cwnd由发送方维护（拥塞），rwnd由接收方通告（流量） |
| 慢启动 vs 拥塞避免 | 慢启动指数增长，拥塞避免线性增长 |

### 套接字编程要点
**TCP服务器流程：**
```
socket() → bind() → listen() → accept() → read/write() → close()
```

**TCP客户端流程：**
```
socket() → connect() → read/write() → close()
```

**UDP流程：**
```
socket() → bind()（服务器）→ sendto/recvfrom() → close()
```

---
> 💡 学习建议：
> 1. 理解TCP和UDP的本质区别
> 2. 重点掌握三次握手、四次挥手的过程和原因
> 3. 理解可靠传输的实现机制（序号、确认、重传）
> 4. 区分流量控制和拥塞控制
> 5. 记住常用端口号
