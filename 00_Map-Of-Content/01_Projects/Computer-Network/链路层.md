---
tags:
  - Knowledge/Computer-Network
created: 2025-10-27
author:
  - ln1
status: In Progress
---
## 1.数据链路层的设计问题  
### 1.1.数据链路层在协议栈中的位置：  
![数据链路层在协议栈中的位置.png](Pasted%20Graphic.png)  
### 1.2.链路层的功能：  
* 成帧（Framing）  
* 差错控制（Error Control）  
* 流量控制（Flow Control）  
    * 确保发送方的**发送速率**，不大于接收方的处理速率

> 链路层的三大核心功能：成帧解决"数据边界"问题，差错控制解决"传输可靠性"问题，流量控制解决"速度匹配"问题  
### 1.3.链路层提供的服务：  
* **无确认 无连接 **服务（Unacknowledged connectionless）  
    * 接收方不对收到的帧进行确认  
    * 以太网  
* **有确认 无连接 **服务 (Acknowledged connectionless)  
    * 每一帧都得到单独的确认  
    * 无线信道  
* **有确认 有连接 **服务 (Acknowledged connection-oriented)  
    * 长延时的不可靠信道

> 服务类型的选择取决于信道特性：可靠信道用无确认服务，不可靠信道用有确认服务，长延时信道用有连接服务  
### 1.4.成帧(Framing)  
![分组和帧的关系.png](Pasted%20Graphic%201.png)  
**关键问题**：如何标识一个帧的开始  
  
1. 字节计数法(Byte count)：无差错传输，当出现了一个字节**差错**的情形，破坏了帧的边界，导致一连串帧的错误。

> 字节计数法最简单但最脆弱：一个计数错误会导致后续所有帧都错位  
2. 带字节填充的定界符法：  
    * 定界符(FLAG):一个特殊的字节，用于区分前后两个不同的帧。  
    * 为了解决有效荷载部分包含与“定界符”相同的字节：  
        * 发送方检查有效荷载，进行字节填充。  
        * ![Pasted Graphic 2.png](Pasted%20Graphic%202.png)  
        * 接收方的处理：  
            * 收到**ESC：**则后一字节无条件成为有效载荷，不予检查。  
            * 收到**FLAG**：则称为帧的**边界。**

> 字节填充法类似编程中的转义字符：\n表示换行而不是反斜杠+n  
            * ![ESC FLAG](Pasted%20Graphic%203.png)  
3. 带**比特**填充的定界符法：  
    * 发送方检查**有效载荷**，若其中出现连续5个1比特，则直接插入1个0比特。  
    * ![011111011111100011100010](Pasted%20Graphic%204.png)  
    * 接收方的处理：若出现连续**5个1**比特：  
        * 若下一比特为0，则为**有效载荷**，直接**丢弃0**比特

> 比特填充法更精细：在比特级别进行填充，定界符通常是01111110（6个连续的1）  
        * 若下一比特为1，则连同后一比特的0，构成**定界符**，一帧结束。  
        * ![Pasted Graphic 5.png](Pasted%20Graphic%205.png)  
4. 物理层编码违例：  
**核心思想**：选择的定界符不会在数据部分出现。  
* 4B/5B编码方案：  
    - 4比特映射为**5比特编码**，剩余的一半码字(16个码字）未使用，可以用做帧定界符  
* 前导码：  
    - 存在很长的**前导码**（preamble)，可用作定界符。  
* 曼切斯特/查分曼切斯特编码  
    - 正常的信号在周期**中间有跳变**，持续的高电平（或低电平）为违例码，可以用作定界符。

> 编码违例法最优雅：利用物理层编码的特性，用"不可能出现"的码字作为定界符  
### 1.5.差错控制  
> 信道的噪声导致数据传输问题。  

* 差错(incorrect):数据发生错误  
* 丢失(lost):接收方未收到  
* **乱序（out of order)：**先发后到，多次接收  
* 重复(repeatedly delivery):一次发送，多次接收  
解决方案：**差错检测与纠正、确定重传**  
* 确认：**接收方**校验数据，并发给发送方应答，防止****差错****  
* 定时器：**发送方**启动定时器，防止**丢失**  
* 顺序号：**接收方**检查序号，防止**乱序**递交、**重复**递交

> 差错控制的"三板斧"：确认机制处理差错，定时器处理丢失，序号处理乱序和重复  
### 1.6.流量控制  
> 接收方的处理速率有限  
  
解决方案：  
* 基于**反馈**(feedback-based)的流量控制：接收方反馈，发送方调整。  
* 基于**速率**(rate-based)的流量控制：发送方根据内建机制，自行限速。

> 流量控制类似交通管制：反馈式像红绿灯（根据路况调整），速率式像限速标志（固定限制）  
## 2.差错检测和纠正  
### 2.1.差错检测与纠正概述：  
> 通常采用**增加冗余信息(或称校验信息）**的策略。  
  
目标：保证一定差错检测和纠错能力的前提下，减少冗余信息量  
**两种主要策略**：  
* **检错码**（error-detecting code):不能推断哪位发生错误，请求重发  
* **纠错码**(error-correcting code)：定位并纠错，通常用于经常发生错误的例如无线链路。使用纠错码的技术通常称为**前向纠错**（FEC,Forward Error Correction)  

**码字(code word)**：一个包含m个数据位和r个校验位的n位单元。  
* 描述为(n,m)码，n = m + r  
**码率(code rate)**：码字中不含冗余部分所占的比例，可以用m/n表示。  
**海明距离(Hamming distance)**：两个码字之间不同对应比特的数目。  
* 为了检查出d个错，可以使用海明距离为**d+1**的编码。  
* 为了纠正d个错，可以使用海明距离为**2d+1**的编码。

> 海明距离决定纠错能力：距离越大，纠错能力越强，但冗余开销也越大  
### **2.2.典型检错码：**  
* 奇偶校验(Parity Check):增加1位校验位，**可以检查奇数位错误**  
    * 偶校验：保证1的个数为偶数个；  
    * ![0 1 1 01](Pasted%20Graphic%206.png)  
    * 奇校验：保证1的个数为奇数个；

> 奇偶校验最简单但能力有限：只能检测奇数个错误，不能检测偶数个错误  
    * ![Pasted Graphic 7.png](Pasted%20Graphic%207.png)  
* 校验和(Checksum)：主要用于TCP/IP体系中的网络层和传输层。  
    * **发送方**：进行16位二进制补码求和运算，运算结果取反，随数据一同发送

> 校验和的优点是计算简单，缺点是检错能力相对较弱  
* 循环冗余校验(Cyclic Redundancy Check,CRC):数据链路层广泛使用的检验方法。  
* ![Pasted Graphic 11.png](Pasted%20Graphic%2011.png)  
1. 在 D 后补 n 个 0（即乘以 2^n）。  
2. 用 G 对 D·2^n 进行模 2 除法。  
3. 余数 R（n 位）即为 CRC 校验码，不足 n 位时前补 0。

> CRC是数据链路层的"金标准"：检错能力强，计算效率高，硬件实现简单  
* ![• D = 1010001101](Pasted%20Graphic%2010.png)  
  
### **2.3.典型纠错码：**  
**设计纠错码**：  
为了纠正单比特错误，需要为每个信息位加上足够多的校验位，使得每种出错情况都有唯一的标识。  
数学上表现为：  
- m个信息位，r个校验位，纠正单比特错  
![(m+r+1) ≤ 2"](Pasted%20Graphic%2013.png)  
**海明码：**以奇偶校验为基础，如何找到出错位置，提供==1位==纠错能力。  
  
**检验位：**2的幂次方位（记为p1,p2,p4,p8)

> 海明码的巧妙之处：用多个奇偶校验位的组合来精确定位错误位置  
**子集的选择与校验位计算：**  
![Pasted Graphic 1.png](Pasted%20Graphic%201.png)  
![Pasted Graphic.png](Pasted%20Graphic.png)  
**定位错误与纠正：**  
![Pasted Graphic 2.png](Pasted%20Graphic%202.png)  
定位错误位于第4列  
![Pasted Graphic 3.png](Pasted%20Graphic%203.png)  
定位错误位于第*2*行  
  
****因此定位错误位于第2行、第4列。****  
  
**Reed-Solomon code**:以有限域计算为基础，提供多位纠错能力。  
* RS 会将需要编码的流数据重新排列为以Symbol为==单位的数据块==  
* M 表示符号的大小，如 m = 4 表示每个符号由 4 位二进制数组成  
* 对于一个 (n, k) RS编码，k为原始数据符号数，n-k 为校验符号数  
* n - k = 2t，==t ==表示==能够纠正的错误数==

> RS码广泛用于CD、DVD、蓝光光盘等存储设备，能纠正连续的多个错误  
**编码方式：**  
* 每个 Symbol 为 4 位二进制数 (m = 4，相当一个 16 进制值)  
* 原始数据为 11 个 Symbols (k = 11)，校验数据为 4 个 Symbols (2t = 4)，  
*  完成的编码为 15 个 Symbols (n = 15)  
* 假设原始数据为 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]（每个为一个symbol）  
*  后面补 4 个 0，即 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]，并以多项式形式表示  
* 除以生成多项式：  
* ![8(X)= II(+-2))= (X-1)(8-2)14-4)14-8) = x'+15x3+3*2+x+12](Pasted%20Graphic%205.png)  
* 取最终余数 [3, 3, 12, 12] 加到补过0的原始数据中  
* 生成最终编码 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 3, 3, 12, 12]，可以用多项式表达，记为C(x)  
**具体计算过程：**  
![agnonnadra](Pasted%20Graphic%206.png)  
**解码：**  
1. 根据收到的码字，计算**Syndromes**值。  
    * 若计算出的**Syndromes**全为0，则判断码字美元发生错误，直接提取message symbols  
    * ![•*99+8(x) =П(x-2) = (x-1)(x- 2)(x-4)(x- 8) =x*+ 15x'+3x2+x+12](Pasted%20Graphic%207.png)  
2. 定位错误的位置和值：  
    * 如果传输过程中有错，则接收数据就是原始数据叠加上错误数据。  
    * 然后接下来是一堆算法……  
3. 恢复原始信息：将错误信息E(x)加到接收信息R(x)上，即可纠正错误信息。  
## 3.基本的数据链路层协议  
### 3.1.定义与假设  
* 物理层运行在专用硬件  
* 数据链路层作为操作系统的一部分运行在CPU  
* 分层进程独立假设  
* 提供可靠服务假设  
* 只处理通信错误假设  
### 3.2.乌托邦式单工协议  
* **单工**(Simplex)协议：数据单向传输。  
* 乌托邦：完美但不现实的协议  
    * 不处理任何流量控制或纠错工作  
    * 接近于无确认的无连接服务，必须依赖更高层级解决上述问题

> 乌托邦协议是理论起点：假设完美环境，为后续协议的复杂性提供对比基准  
    * ![• 95650Blt (frame_arrival)](Pasted%20Graphic%208.png)  
### 3.3.无错信道单工停止-等待协议  
**==不再==假设：**  
* 接收方能够以无限高速进来的数据；  
* 发送方以高于接收方能处理到达帧的速度发送帧，导致接收方被“淹没”（overwhelming）  
**仍然假设：**  
* 通信信道不会出错（Error-Free）  
* 数据传输保持单向，但是需要双向传输链路（半双工物理信道）  
**停-等式协议（stop-and-wait):**  
* 发送方发送一帧后暂停，等待**确认**(Acknowldgement)到达后发送下一帧。  
* 接收方完成接收后，回复**确认**接收。

> 停等协议解决了流量控制问题，但引入了效率问题：发送方大部分时间在等待  
* ![while (true) {](Pasted%20Graphic%209.png)  
### 3.4.有错信道单工停止-等待协议  
****假设：****  
* 通信信道可能会出错，导致帧可能会被破坏或者丢失。  
**简单的解决方案：**  
* 发送方增加一个**计时器**（timer），如果经过一段时间没有收到确认，发送方超时，将再次发送该帧。  
* 通过**序号**（SEQ:sequence number):来避免重复的帧造成的干扰。

> 定时器+序号是可靠传输的核心机制：定时器处理丢失，序号处理重复  
![>184605](Pasted%20Graphic%2010.png)  
**效率的评估：**  
• F = frame size (bits)  
• R = channel capacity (Bandwidth in bits/second)  
• I = propagation delay + processor service time (second)  
• 每帧发送时间 (Time to transmit a single frame) = F/R  
• 总延迟 (Total Delay) = D =2 I  
• 停止等待协议的发送工作时间是F/R，空闲时间是D  
• 当 F<D 时：信道利用率 (line utilization)=F/(F+R·D) < 50%

> 停等协议的效率瓶颈：传输时间短、等待时间长时，信道利用率极低  
**效率问题：**  
停止等待协议只能有一个没有被确认的帧在发送中。  
> 长肥网络（LFN，Long Fat Network）：如果一个网络的带宽-延迟乘积（bandwidth- delay product）很明显的大于10^5bit(~12kB)****，则可以被认为是长肥网络。  

****问题：****  
* 信道利用率低  
* 一种提高效率低方法：使用更大的帧。  
## 4.滑动窗口协议  
### 4.1.停等协议的性能问题  
* 停止-等待机制**降低了**信道利用率  
* 解决办法：流水线协议或管道协议：允许发送方在没收到确认前**连续发送**多个帧。

> 流水线思想：像工厂流水线一样，不等前一个产品完成就开始下一个产品  
### 4.2.滑动窗口协议  
**基本思想：**  
* 窗口机制：  
    * 发送方和接收方都具有一定容量的缓冲区（即窗口），发送端在收到确认之前可以发送多个帧  
**目的：**  
* 对可以连续发出的最多帧（已发出但未确认的帧）做限制

> 滑动窗口是流量控制和可靠传输的完美结合：既提高效率又保证可靠性  
**序号使用：**  
* 循环**重复使用**有限的帧序号  
**流量控制：**  
* 发送窗口：其大小记作W_T，表示在收到对方确认的消息之前，可以连续发出的最多数据帧数  
* 接收窗口：其大小记作W_R，表示可以连续接收最多数据帧数  
累计确认：**不必**对收到的分组**逐个发送确认**，而是按序到达的最后一个分组发送确认。

> 累计确认减少了确认帧的数量，但可能导致不必要的重传  
**基本原理：**  
发送方和接收方各有一个固定大小的“窗口”，控制可连续发送或接收的帧数量。  
	•	发送方在未收到确认前可连续发送多个帧，实现流水线式传输。  
	•	收到确认后，窗口向前滑动，释放已确认的序号空间。  
	•	帧序号有限，采用循环使用（如 0～7）。  
	•	通过窗口滑动实现**流量控制**与**高效传输**。  
![2i25 (Wy=WR=1, F532100701)](Pasted%20Graphic.png)  
![1.#fk: ack expected = frame_expected](Pasted%20Graphic%201.png)  
### 4.3.回退N协议  
出错全部重发：  
* 当接收端收到一个**出错帧或乱序帧**时，丢弃所有的后续帧，并且不为这些帧发送确认。  
* 发送端**超时**，**重传所有**未被确认的帧  
* 优点：连续发送提高了信道利用率  
* 缺点：按序接收，出错后即便有正确帧也丢弃重传

> 回退N协议简单但"一刀切"：一个帧出错，后面所有帧都要重传  
**基本原理：**  
- 当发送方发送了N个帧后，若发现该N帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就重新发送出错帧及其后的N帧。  
- 滑动窗口长度：出错全部重发时，若帧序号为n位，接收窗口W_R = 1，发送窗口$W_T \leq 2^n - 1$。

> 窗口大小限制是为了避免序号重复导致的混淆  
- ![Pasted Graphic 2.png](Pasted%20Graphic%202.png)  
* **接收方是“累计确认（Cumulative ACK）”方式：**  
* 每次只对**按序正确接收到的最后一个帧**发送 ACK。  
* 如果收到了乱序帧（例如期望的是帧 3，但先来了帧 4），就**丢弃帧 4**，并**重复发送上一次的 ACK（即 ACK 2）**。  
### 4.4.选择重传协议   
若发送方发出连续的若干帧后，收到对其中某一帧的否认帧，或某一帧的定时器超时，**则只重传该出错帧或计时器超时**的数据帧。

> 选择重传更精确：只重传真正出错的帧，但实现复杂度更高  
**适用场景：**  
* 对应**接收窗口大于1**的情况，即暂存接收窗口中序号在出错帧之后的数据帧。  
**基本原理：**  
* 在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏；接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK；发送端接收到NAK时，只重传出错的帧  
* 如果落在窗口内的帧从未接受过，那么存储起来，等比它序列号小的所有帧都正确接收后，按次序交付给网络层  
* 接收端收到的数据包的顺序可能和发送的数据包顺序不一样，因此在数据包里必须含有顺序号来帮助接收端进行排序。  
**滑动窗口长度：**  
* 发送窗口的尺寸：$W_T \leq 2^{n-1}$,发送窗口应等于或小于序号空间的一半。

> 选择重传的窗口限制更严格：最多只能是序号空间的一半  
**实现要点：**  
* SR是**给每一个PDU设置定时器**，发送端**只重传出错PDU**。

> 选择重传需要为每个帧单独设置定时器，增加了实现复杂度  
## 5.数据链路协议实例  
### 5.1.PPP协议简介：  
*  （Point-to-Point Protocol）协议是目前使用最多的**数据链路层协议**之一。  
* 只进行检错，PPP协议是不可靠传输协议。  
* 不支持多点连接。  
* 支持全双工链路。

> PPP协议设计简单实用：专注于点对点连接，不追求复杂的可靠性机制  
**链路控制协议LCP（Link Control Protocol）：**用来建立、配置和测试数据的链路控制协议，通信双方可协商一些选项。  
**网络控制协议NCP（Network Control Protocol）：其中的每个协议支持一种不同的网络层协议，如IP、OSI的网络层】DECnet、AppleTalk等。**

> PPP的分层设计：LCP处理链路层事务，NCP处理网络层协议的多样性  
  
PPP协议的帧格式：  
1. 字节填充：避免在信息字段中出现和**标志字段**一样的比特组合（0X7E）。  
    * PPP使用异步传输时，定义转义字符0X7D，并使用字节填充  
        - －将信息字段中出现的0x7E 字节转变成为2字节序列(0x7D, 0x5E)  
        - －若信息字段中出现一个0x7D 字节, 则将其转变成为2字节序列(0x7D, 0x5D)  
        - －若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变  
    * 在发送端进行了字节填充，链路上传递的信息字节数超过原来的信息字节数。接收端进行字节填充相反的工作，恢复为原来的信息

> PPP的字节填充规则很详细：不仅处理标志字符，还处理转义字符和控制字符  
2. 零比特填充：五个连1后接一个0.

> PPP支持两种填充方式：字节填充用于异步传输，比特填充用于同步传输  
![SHIATE](Pasted%20Graphic.png)  
### 5.2.PPPoE  
* Ethernet优点  
    * 原理简单，应用非常广，设备成本低  
*  Ethernet缺点  
    * 安全性较低、不宜管理：使用广播信道，造成了安全性较低，无认证功能  
* PPP优点  
    * 原理简单  
    * 安全性高：点对点信道，提供认证机制  
    * 提供良好的访问控制和计费功能  
**PPPoE（Point-to-Point Protocol over Ethernet）**  
* 提供在以太网链路上的PPP连接  
* 实现了传统以太网不能提供的身份验证、加密，以及压缩等功能  
* 实现基于用户的访问控制、计费、业务类型分类等，运营商广泛支持  
* PPPoE使用Client/Server模型，**服务器通常是接入服务器**

> PPPoE结合了以太网的便利性和PPP的安全性，是宽带接入的主流技术  
  
组网**方式：**  
  
![PPPoE Server](Pasted%20Graphic%201.png)  
![PPPoE Client](Pasted%20Graphic%202.png)  
**PPPoE可分为三个阶段：**  
* **Discovery阶段**  
	− 获取对方以太网地址，确定PPPoE会话ID  
* **Session阶段**  
	− PPP协商阶段  
	− PPP报数数据传输  
* **Terminate阶段**  
	− 会话建立以后的任意时刻，发送报文结束会话

> PPPoE的三阶段设计：Discovery建立连接，Session传输数据，Terminate释放连接  
