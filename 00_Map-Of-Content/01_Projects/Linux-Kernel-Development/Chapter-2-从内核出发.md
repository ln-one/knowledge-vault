---
tags:
  - Knowledge/Operating-Systems/Linux
  - Knowledge/Operating-Systems/Kernel
created: 2025-09-15
author:
  - ln1
status: Done
---
## 1.获取内核源码
 [Linux源码](http:///www.kernel.org)
### 1.1.使用Git

### 1.2.安装内核源代码

### 1.3.使用补丁

## 2.内核源码树
![[Pasted image 20250915100306.png]]
![[Pasted image 20250915100337.png]]
## 3.编译内核
### 3.1.配置内核
- Yes
- No
- Module:该配置项被选定了，但编译的时候这部分功能的实现代码是以**模块**的形式生成。
命令行工具：
`make config`
图形界面工具：
`make menuconfig`
或者基于gtk+的工具：
`make gconfig`
默认配置：
`make defconfig`
更新配置：
`make oldconfig`
内核配置好后，使用简单的命令来编译：`make`
### 3.2.减少垃圾信息
`make > .../detritus`
`make > /dev/null`
### 3.3.衍生多个编译作业
make程序能把编译过程拆分成多个**并行**的作业。有助于极大地加快多处理器系统上的编译过程，有利于**改善处理器的利用率**。
`make -jn`
在实际中，每个处理器上一般衍生出一个或者两个作业，比如16核：
`make -j32 > /dev/null`
### 3.4.安装新内核
`make modules_install`
## 4.内核开发的特点
### 4.1.无libc库或标准头文件
- 对于内核来说，完整的C库**太大且太低效**了。
- 先有鸡还是先有蛋。
	printk()允许通过指定一个标志来设置优先级。syslog程序可以通过读取该缓存区来获取内核信息。
### 4.2.GNU C
Linux内核使用C语言编写，且并不完全符合ANSI C标准，要用到gcc提供的许多语言的扩展部分。
#### 1.内联(inline)函数：
- 函数会**在它所调用的位置上展开**。
- 编译器会把调用函数的代码和函数本身放在一起进行优化。
- 但代码会变长，占用**更多的内存空间**或占用**更多的指令缓存**。
- 通常把对时间要求比较高，而本身长度又比较短的函数定义为内联函数。
- 内联函数必须在使用之前就定义好，否则编译器没法把这个函数展开。
- 在内核中，为了**类型安全**和**易读性**，优先使用内联函数而不是复杂的宏。
#### 2.内联汇编：
- gcc编译器支持在C函数中**嵌入汇编**指令。
- 通常使用**asm()**指令嵌入汇编代码。
- Linux内核混合使用了C语言和汇编语言。
- 偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言。
#### 3.分支声明：
内建了一条指令用于优化条件选择语句：
1. 把这个选择标记成绝少发生的分支：
```
if(unlikely(error)){
/* ... */
}
```
2. 把这个选择标记为通常为真的分支：
```
if(likely(success)){
/* ... */
}
```
判断正确，则性能优化，错误，则性能下降。
### 4.3.没有内存保护机制
- 进行非法的内存访问而无通知；
- 内核中的内存都**不分页**。
### 4.4.不要轻易在内核中使用浮点数
在执行浮点指令时到底会做些什么，因体系结构不同，内核的选择也不同。内核**并不能完美地支持浮点操作**。
### 4.5.容积小而固定的栈
- 内核栈的**准确大小**随体系结构而变。
- 从历史上，内核栈的**固定大小**是两页：32bit机的内核栈是8KB，64bit机的内核栈是16KB。
### 4.6.同步和并发
内核很容易产生**竞争**条件。
- Linux是**抢占多任务**操作系统。
- Linux内核**支持对称多处理器系统**（SMP）。
- 中断是异步到来的，完全不顾及当前正在执行的代码。
- Linux内核是可以**抢占**的。
### 4.7.可移植性的重要性
- Linux的大部分C代码应该与体系结构无关，在许多不同体系结构的计算机上都能编译和执行。
- 必须把体系结构相关的代码从内核代码树的特定目录中适当地分离出来。