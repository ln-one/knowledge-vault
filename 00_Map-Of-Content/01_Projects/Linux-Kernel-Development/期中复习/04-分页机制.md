# 04 - 分页机制

> 💡 **本章目标**：理解分页机制的原理，掌握线性地址到物理地址的转换过程

> ⚠️ **重要程度**：⭐⭐⭐（理解概念，会计算）

---

## 📖 目录
1. [为什么需要分页](#为什么需要分页)
2. [分段 vs 分页](#分段-vs-分页)
3. [线性地址的结构](#线性地址的结构)
4. [两级页表结构](#两级页表结构)
5. [地址转换过程](#地址转换过程)
6. [页目录项和页表项](#页目录项和页表项)
7. [启用分页](#启用分页)

---

## 为什么需要分页？

### 🤔 只有分段的问题

```
问题1：内存碎片
┌─────────────────────────────────────┐
│  物理内存                            │
├─────────────────────────────────────┤
│  [程序A: 100KB]                     │
│  [空闲: 50KB]    ← 碎片             │
│  [程序B: 200KB]                     │
│  [空闲: 30KB]    ← 碎片             │
│  [程序C: 150KB]                     │
│  [空闲: 70KB]    ← 碎片             │
└─────────────────────────────────────┘
总共150KB空闲，但无法加载一个150KB的程序！

问题2：程序必须连续存放
程序需要500KB，但内存中没有连续的500KB空间

问题3：无法实现虚拟内存
程序的大小受物理内存限制
```

### ✅ 分页的优势

```
优势1：消除外部碎片
┌─────────────────────────────────────┐
│  物理内存（分成4KB的页）             │
├─────────────────────────────────────┤
│  [页0: 程序A]                       │
│  [页1: 程序B]                       │
│  [页2: 程序A]                       │
│  [页3: 程序C]                       │
│  [页4: 程序B]                       │
│  ...                                │
└─────────────────────────────────────┘
程序可以分散存放，不需要连续空间

优势2：实现虚拟内存
程序可以比物理内存大
不常用的页可以换出到磁盘

优势3：内存保护
每个页可以设置访问权限
```

---

## 分段 vs 分页

### 📊 对比表

| 特性 | 分段 | 分页 |
|------|------|------|
| **大小** | 可变（由段界限决定） | 固定（4KB或4MB） |
| **地址空间** | 逻辑地址 → 线性地址 | 线性地址 → 物理地址 |
| **目的** | 逻辑划分，保护 | 内存管理，虚拟内存 |
| **对程序员** | 可见（需要指定段） | 透明（自动转换） |
| **碎片** | 外部碎片 | 内部碎片（页内） |

### 🔄 完整的地址转换

```
┌─────────────────────────────────────────────────────────┐
│  逻辑地址 (选择子:偏移)                                  │
└─────────────────────────────────────────────────────────┘
                    ↓ 分段机制
┌─────────────────────────────────────────────────────────┐
│  线性地址 (32位)                                         │
└─────────────────────────────────────────────────────────┘
                    ↓ 分页机制（如果启用）
┌─────────────────────────────────────────────────────────┐
│  物理地址 (32位)                                         │
└─────────────────────────────────────────────────────────┘
```

> 💡 **注意**：
> - 分段是必须的（保护模式的基础）
> - 分页是可选的（通过CR0的PG位控制）
> - 如果不启用分页，线性地址 = 物理地址

---

## 线性地址的结构

### 📊 32位线性地址的划分

```
┌────────────────────────────────────────────────────────┐
│  线性地址 (32位)                                        │
├────────────────────────────────────────────────────────┤
│  31        22 21        12 11                       0  │
│  ┌───────────┬────────────┬─────────────────────────┐ │
│  │ 目录索引  │  页表索引  │      页内偏移           │ │
│  │ (10位)    │  (10位)    │      (12位)             │ │
│  └───────────┴────────────┴─────────────────────────┘ │
│       ↓            ↓                  ↓                │
│   0-1023       0-1023            0-4095               │
└────────────────────────────────────────────────────────┘
```

### 📝 字段说明

| 字段 | 位数 | 范围 | 说明 |
|------|------|------|------|
| **目录索引** | 10位 | 0-1023 | 在页目录表中的索引 |
| **页表索引** | 10位 | 0-1023 | 在页表中的索引 |
| **页内偏移** | 12位 | 0-4095 | 在页内的偏移（4KB=2^12） |

### 🧮 计算示例

```
例1：线性地址 = 0x00401234

转换为二进制：
0000 0000 0100 0000 0001 0010 0011 0100

划分：
目录索引 = 00 0000 0001 (二进制) = 1
页表索引 = 00 0000 0001 (二进制) = 1  
页内偏移 = 0010 0011 0100 (二进制) = 0x234

解释：
- 在页目录表的第1项
- 在页表的第1项
- 页内偏移0x234
```

```
例2：线性地址 = 0x12345678

十六进制拆分：
0x123 45 678
 ↓    ↓   ↓
目录  页表 偏移

目录索引 = 0x123 = 291
页表索引 = 0x45 = 69
页内偏移 = 0x678 = 1656
```

> 💡 **快速计算技巧**：
> - 目录索引 = 线性地址 >> 22
> - 页表索引 = (线性地址 >> 12) & 0x3FF
> - 页内偏移 = 线性地址 & 0xFFF

---

## 两级页表结构

### 🎯 为什么需要两级页表？

```
如果只用一级页表：
- 32位地址空间 = 4GB
- 页大小 = 4KB
- 需要的页表项 = 4GB / 4KB = 1M个
- 每个页表项 = 4字节
- 页表大小 = 1M × 4B = 4MB

问题：每个进程都需要4MB的页表！

使用两级页表：
- 页目录表：1024项 × 4B = 4KB
- 每个页表：1024项 × 4B = 4KB
- 只需要分配用到的页表
- 大大节省内存
```

### 📊 两级页表结构图

```
┌─────────────────────────────────────────────────────────┐
│  CR3寄存器                                               │
│  (页目录基址寄存器)                                      │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  页目录表 (Page Directory)                               │
│  ┌──────────────────────────────────────────┐           │
│  │ 索引0: [页表0的物理地址 | 属性]          │           │
│  │ 索引1: [页表1的物理地址 | 属性]          │           │
│  │ 索引2: [页表2的物理地址 | 属性]          │           │
│  │ ...                                      │           │
│  │ 索引1023: [页表1023的物理地址 | 属性]    │           │
│  └──────────────────────────────────────────┘           │
│  共1024项，每项4字节，总共4KB                            │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  页表 (Page Table)                                       │
│  ┌──────────────────────────────────────────┐           │
│  │ 索引0: [页框0的物理地址 | 属性]          │           │
│  │ 索引1: [页框1的物理地址 | 属性]          │           │
│  │ 索引2: [页框2的物理地址 | 属性]          │           │
│  │ ...                                      │           │
│  │ 索引1023: [页框1023的物理地址 | 属性]    │           │
│  └──────────────────────────────────────────┘           │
│  共1024项，每项4字节，总共4KB                            │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  页框 (Page Frame)                                       │
│  物理内存中的4KB块                                       │
└─────────────────────────────────────────────────────────┘
```

---

## 地址转换过程

### 🔄 完整的转换流程

```
┌─────────────────────────────────────────────────────────┐
│  1. 从线性地址提取三个部分                               │
│     目录索引 | 页表索引 | 页内偏移                       │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  2. 从CR3获取页目录表基址                                │
│     CR3 → 页目录表物理地址                               │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  3. 用目录索引在页目录表中查找                           │
│     页目录表基址 + 目录索引×4 → 页目录项                 │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  4. 从页目录项获取页表基址                               │
│     页目录项 → 页表物理地址                              │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  5. 用页表索引在页表中查找                               │
│     页表基址 + 页表索引×4 → 页表项                       │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  6. 从页表项获取页框基址                                 │
│     页表项 → 页框物理地址                                │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│  7. 计算最终物理地址                                     │
│     物理地址 = 页框基址 + 页内偏移                       │
└─────────────────────────────────────────────────────────┘
```

### 📝 实际例子

```
假设：
- CR3 = 0x00200000 (页目录表在2MB处)
- 线性地址 = 0x00401234

步骤1：提取三部分
  目录索引 = 0x001 = 1
  页表索引 = 0x001 = 1
  页内偏移 = 0x234 = 564

步骤2：获取页目录表基址
  页目录表基址 = CR3 = 0x00200000

步骤3：查找页目录项
  页目录项地址 = 0x00200000 + 1×4 = 0x00200004
  假设页目录项内容 = 0x00201007
  (最低12位是属性，高20位是页表基址)

步骤4：获取页表基址
  页表基址 = 0x00201007 & 0xFFFFF000 = 0x00201000

步骤5：查找页表项
  页表项地址 = 0x00201000 + 1×4 = 0x00201004
  假设页表项内容 = 0x00305007

步骤6：获取页框基址
  页框基址 = 0x00305007 & 0xFFFFF000 = 0x00305000

步骤7：计算物理地址
  物理地址 = 0x00305000 + 0x234 = 0x00305234
```

---

## 页目录项和页表项

### 📊 页目录项/页表项结构（32位）

```
┌────────────────────────────────────────────────────────┐
│  31                    12 11  9 8 7 6 5 4 3 2 1 0      │
│  ┌──────────────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐   │
│  │  页框基址(高20位)    │AVL  │G│S│0│A│D│W│U│R│P│   │
│  └──────────────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘   │
│         ↓                        ↓ ↓   ↓ ↓ ↓ ↓ ↓ ↓     │
│    页框物理地址              属性位                     │
└────────────────────────────────────────────────────────┘
```

### 📝 属性位说明

| 位 | 名称 | 说明 |
|---|------|------|
| **P** | Present | 1=页在内存中，0=页不在内存（缺页） |
| **R/W** | Read/Write | 1=可读写，0=只读 |
| **U/S** | User/Supervisor | 1=用户级，0=超级用户级 |
| **PWT** | Page Write-Through | 页级写透 |
| **PCD** | Page Cache Disable | 页级缓存禁止 |
| **A** | Accessed | 1=页被访问过 |
| **D** | Dirty | 1=页被写过（仅页表项有） |
| **PS** | Page Size | 1=4MB页，0=4KB页（仅页目录项有） |
| **G** | Global | 全局页（仅页表项有） |
| **AVL** | Available | 可供系统程序使用 |

### 💻 创建页目录项和页表项

```asm
; 页目录项/页表项的属性常量
PG_P    equ 1    ; Present
PG_RWW  equ 2    ; Read/Write
PG_USS  equ 4    ; User/Supervisor

; 创建页目录项
; 页表基址 = 0x00201000
; 属性 = Present + Read/Write + User
mov eax, 0x00201000
or  eax, PG_P | PG_RWW | PG_USS
mov [PageDirBase], eax

; 创建页表项
; 页框基址 = 0x00305000
; 属性 = Present + Read/Write + User
mov eax, 0x00305000
or  eax, PG_P | PG_RWW | PG_USS
mov [PageTableBase], eax
```

### 🔍 属性位的作用

#### P位（Present）
```
P = 0：页不在内存
  → 访问时产生缺页异常(Page Fault)
  → 操作系统从磁盘加载页

P = 1：页在内存
  → 正常访问
```

#### R/W位（Read/Write）
```
R/W = 0：只读
  → 写操作会产生保护异常

R/W = 1：可读写
  → 正常读写
```

#### U/S位（User/Supervisor）
```
U/S = 0：超级用户级（Ring 0-2）
  → Ring 3不能访问

U/S = 1：用户级（Ring 3）
  → 所有特权级都能访问
```

#### A位（Accessed）
```
A = 0：页未被访问
A = 1：页被访问过

作用：操作系统可以根据A位实现页面置换算法
```

#### D位（Dirty）
```
D = 0：页未被修改
D = 1：页被写过

作用：换出页面时，只有D=1的页需要写回磁盘
```

---

## 启用分页

### 🔧 启用分页的步骤

```
步骤1：准备页目录表和页表
  ├─ 分配内存（页对齐）
  ├─ 填写页目录项
  └─ 填写页表项

步骤2：将页目录表地址写入CR3
  mov eax, PageDirBase
  mov cr3, eax

步骤3：设置CR0的PG位
  mov eax, cr0
  or  eax, 80000000h    ; 设置PG位(bit 31)
  mov cr0, eax

步骤4：分页机制启用！
```

### 💻 代码示例

```asm
; 定义页目录表和页表的位置
PageDirBase equ 200000h    ; 页目录表在2MB处
PageTblBase equ 201000h    ; 页表在2MB+4KB处

; 设置页目录表
SetupPaging:
    ; 1. 初始化页目录表（全部清零）
    mov ax, SelectorData
    mov es, ax
    mov edi, PageDirBase
    xor eax, eax
    mov ecx, 1024          ; 1024个页目录项
    cld
    rep stosd              ; 清零

    ; 2. 设置第一个页目录项
    mov eax, PageTblBase
    or  eax, PG_P | PG_RWW | PG_USS
    mov [PageDirBase], eax

    ; 3. 初始化页表
    mov edi, PageTblBase
    xor eax, eax
    or  eax, PG_P | PG_RWW | PG_USS
    mov ecx, 1024          ; 1024个页表项
.1:
    stosd
    add eax, 4096          ; 下一个页框（4KB）
    loop .1

    ; 4. 加载CR3
    mov eax, PageDirBase
    mov cr3, eax

    ; 5. 启用分页
    mov eax, cr0
    or  eax, 80000000h     ; 设置PG位
    mov cr0, eax

    ret
```

### 📝 简单的页表设置

```asm
; 最简单的设置：线性地址 = 物理地址
; (恒等映射，Identity Mapping)

; 页目录表：只设置第一项
mov eax, PageTblBase | PG_P | PG_RWW | PG_USS
mov [PageDirBase], eax

; 页表：映射前4MB
mov edi, PageTblBase
mov eax, PG_P | PG_RWW | PG_USS
mov ecx, 1024
.loop:
    mov [edi], eax
    add eax, 4096          ; 下一个4KB页
    add edi, 4
    loop .loop
```

### ⚠️ 注意事项

```
1. 页目录表和页表必须页对齐（地址是4KB的倍数）

2. 启用分页前，必须先设置好页表
   否则会立即产生缺页异常

3. 启用分页后，所有地址都是线性地址
   需要通过页表转换为物理地址

4. CR3的改变会刷新TLB（Translation Lookaside Buffer）
```

---

## 🎯 本章小结

### 核心概念

| 概念 | 说明 |
|------|------|
| **分页** | 将内存划分为固定大小的页（4KB） |
| **页目录表** | 一级页表，1024项，每项指向一个页表 |
| **页表** | 二级页表，1024项，每项指向一个页框 |
| **CR3** | 页目录基址寄存器 |

### 地址转换公式

```
线性地址 = 目录索引(10位) | 页表索引(10位) | 页内偏移(12位)

物理地址 = 页框基址 + 页内偏移

其中：
- 页框基址通过两级页表查找得到
- 页内偏移直接来自线性地址
```

### 快速计算

```
目录索引 = 线性地址 >> 22
页表索引 = (线性地址 >> 12) & 0x3FF
页内偏移 = 线性地址 & 0xFFF
```

### 重要属性位

```
P (Present)：页是否在内存
R/W：读写权限
U/S：用户/超级用户
A (Accessed)：是否被访问
D (Dirty)：是否被修改
```

---

## ✅ 自我检查

- [ ] 能说出分页的优势
- [ ] 能画出两级页表的结构
- [ ] 能从线性地址提取目录索引、页表索引、页内偏移
- [ ] 能描述地址转换的完整过程
- [ ] 能说出页目录项和页表项的结构
- [ ] 能解释P、R/W、U/S等属性位的作用
- [ ] 能写出启用分页的代码

---

**下一章**：[05-中断与异常.md](05-中断与异常.md) - 学习中断处理机制
