# IA- 32 保护模式和鲲鹏处理器

```
Chapter 01
```

### 从 8086 至 80386

#### ❑ 1978 年Intel发布 8086

###### ➢ 16 位字长， 20 位地址线，寻址范围1MB

#### ❑ 1982 年Intel发布 80286

###### ➢ 16 位字长， 24 位地址线，寻址范围16MB

```
➢引入保护模式（Protected Mode）
➢ 8086 所支持的模式被称作为实模式（Real
Mode）
```
#### ❑ 1985 年Intel发布 80386

###### ➢ 32 位字长， 32 位地址线，寻址范围4GB


### 实模式

#### ❑ 实地址模式（Real Address Mode）

#### ❑ 通过 20 位地址分段访问1MB地址空间

#### ❑ 程序可以直接访问BIOS中断和外设

#### ❑ 硬件层不支持任何内存保护或者多任务

#### 处理

#### ❑ 80286 之后的所有x86CPU加电自举（加

#### 电自检和磁盘引导）时首先进入实模式


###### ❑ 硬件为系统软件实现虚拟内存、分页机制、

###### 安全的多任务处理的功能支持

###### ❑ 提供操作系统对应用程序的控制功能：特权

###### 级、实模式应用程序兼容、虚拟 8086 模式

## 保护模式


## 实模式和保护模式寻址比较

#### ❑ 实模式寻址

###### ➢两个 16 位逻辑地址(段地址:偏移地址)组合成

###### 20 位物理地址

#### ❑ 保护模式寻址

```
➢段基址(Segment Base Address)被放在段描
述符(Segment Descriptor)中，GDT(Global
Descriptor Table)保存着所有段描述符的信
息，段选择子(Selector)是指向某个段描述
符的索引
➢寻址只需要给出(段选择子:偏移地址)
```

## 实模式和保护模式寻址比较


## 保护模式寻址

#### ❑ 段寄存器(CS、DS、ES、SS、FS、GS)中

#### 存放的是选择子(Selector)

#### ❑ 选择子是指向某个段描述符的索引

#### ❑ 描述符(Descriptor)是一个64bit的数据结

#### 构(包含段起始地址、限界、属性)


## GDT、LDT和Selector

#### ▪ 全局描述符表(Global Descriptor Table)

#### ▪ 局部描述符表(Local Descriptor Table)

#### ▪ 选择符/选择子(Selector)

```
索引 TI RPL
```
```
13 1 2
```
```
0=GDT/1=LDT 特权级(0-3)
```

## Intel Pentium描述符结构

```
基地址 0 - 15 长度 0 - 15
```
```
基地址 24 - 31 GD^016 长度- 19 PDPLS 类型 基地址 16 - 23
```
```
G: 0:长度以字节为单位， 1 ：长度以页为单位
D: 0: 16 位段， 1 ： 32 位段
```
```
P: 0:段不在内存， 1 ：段在内存中
DPL: 特权级(0-3)
S: 0:系统， 1 ：应用程序
```
```
类型: 段类型和保护
Pentium的代码段描述符
```

## Intel段描述符结构


## 线性地址的计算

```
选择子
```
```
基地址
长度
其它域
```
```
偏移
```
```
+
```
```
32 位线性地址
```
```
选择子、偏移到线性地址的转换
```
```
描述符
```

## 填写GDT

#### ❑ GDT的第一个段通常设置为 0 ，使其成为

#### 空段（null segment）。这个段被Intel保

#### 留，不可被访问。如果加载该空段，则

#### 将产生通用保护异常（General

#### Protection Exception）。通过写 64 位 0 来

#### 填充空段。

```
gdt: ; Address for the GDT
gdt_null: ; Null Segment
dd 0
dd 0
```

## 填写代码段Descriptor

gdt_code: ;Code segment, read/execute, nonconforming
;根据Descriptor的结构，开始的 16 位设置段偏移(Limit, ;15-0)。
保护模式下段偏移可以达到4GB（总共0ffffH的偏移量）
;16 bits segment offset = 0xffff = 4G in protected mode,
Limit(15-0)
dw 0FFFFh
;接下来设置基地址为 0 （内存起始地址，Base 15- 0 ）：
dw 0 ;16 bits base address = 0, Base (15-0)
db 0 ;8 bit base address = 0, Base(23-16)
db 10011010b ;Access rights: A=0; R=1; C=0; E=1; S=1;
;DPL=00; P=
db 11001111b ;G=1; D=1; AV=0; Limit=1111=0xfh
db 0 ;8 bit base address = 0, Base (31-24)


## 填写数据段Descriptor

gdt_data : ;Data segment, read/write, expand down
dw 0FFFFh
dw 0
db 0 ;前 8 位为 0
db 10010010b ;Access rights: A=0; W=1; ED=0; E=0;
;S=1; DPL=00; P=
db 11001111b ;G=1; D=1; AV=0; Limit=1111=0xfh
db 0 ;8 bit base address = 0, Base (31-24)


## 结构数组GDT

[SECTION .gdt]
; GDT
; 段基址, 段界限 , 属性
LABEL_GDT:
LABEL_DESC_NULL: Descriptor 0, 0, 0 ;空描述符
LABEL_DESC_CODE32: Descriptor 0, SegCode32Len -1, DA_C + DA_
LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW ;显存首地址
; GDT 结束

GdtLen equ $ -LABEL_GDT ; GDT长度
GdtPtr dw GdtLen - 1 ; GDT界限
dd 0 ; GDT基地址
; GDT选择子
SelectorCode32 equ LABEL_DESC_CODE32 -LABEL_GDT
SelectorVideo equ LABEL_DESC_VIDEO -LABEL_GDT
; END of [SECTION .gdt]


## 描述符宏Descriptor

```
; 描述符
; usage: Descriptor Base, Limit, Attr
; Base: dd
; Limit: dd (low 20 bits available)
; Attr: dw (lower 4 bits of higher byte are always 0)
%macro Descriptor 3
dw %2 & 0FFFFh ; 段界限 1 (2 字节)
dw %1 & 0FFFFh ; 段基址 1 (2 字节)
db (%1 >> 16) & 0FFh ; 段基址 2 (1 字节)
dw ((%2 >> 8) & 0F00h) | (%3 & 0F0FFh) ; 属性 1+段界限2+属性2(2字节)
db (%1 >> 24) & 0FFh ; 段基址 3 (1 字节)
%endmacro ; 共 8 字节
```
Descriptor宏用比较自动化的方法把段基址、段限界和段
属性安排在描述符中合适的位置


## GDTR结构示意图和CR0寄存器

```
P
G
```
```
C
D
```
```
N
W
```
```
A
M
```
```
W
P
```
```
N
E
```
```
E
T
```
```
T
S
```
```
E
M
```
```
M
P
```
```
P
E
```
31 30 29 18 17 16 5 4 3 2 1 0

```
CR0寄存器结构
```
```
32 位基地址 16 位限界
GDTR寄存器结构
```

## Chapter3\a\pmtest1.asm

###### ❑ 启动后处于 16 位实模式

###### ❑ 做一些初始化工作后进入 32 位保护模式代码段

```
➢ 在屏幕特定位置显示’P’
➢ 进入死循环
```

## Chapter3\a\pmtest1内部布局


## Chapter3\b\pmtest2.asm

###### ❑ 在实模式的DOS下启动程序

###### ❑ 从 16 位实模式进入 32 位保护模式段

```
➢ 显示In Protected Mode now
➢ 读取500000H处的 8 个字节内容并显示
➢ 向500000H开始的地址写入A~Z
➢ 读取读取500000H处的 8 个字节内容并显示
```
❑ 从 32 位保护模式段进入 16 位保护模式段

❑ 从 16 位保护模式段返回实模式下的DOS


## Chapter3\b\pmtest2内存布局


## Chapter3\c\pmtest3.asm

###### ❑ 在实模式的DOS下启动程序

###### ❑ 从 16 位实模式进入 32 位保护模式段

```
➢ 显示In Protected Mode now
➢ 跳入由LDT描述的 32 位保护模式段显示一个”L”
```
❑ 从 32 位保护模式段(LDT描述)进入 16 位保护模
式段

❑ 从 16 位保护模式段返回实模式下的DOS


## Intel保护模式下寻址总结(1)

###### ❑ IA- 32 保护模式下对一个段进行寻址，需要知

```
道段基址(Base Address)、限界(Limit)和访问
权限(Access，由属性给出)，这些信息由一个
64bit的段描述符给出
```
❑ 按理说，寻址时引用 64 - bit段描述符需要将这
个 64 - bit描述符放入一个 64 - bit的段寄存器

❑ Intel为了保持向后兼容，仍然使用 16 - bit段寄
存器

❑ 将 64 - bit段描述符放入一个数组中，而将段寄
存器的值作为下标索引来间接引用


## Intel保护模式下寻址总结(2)

###### ❑ 整个系统有一个全局的段描述符数组，即GDT

```
(Global Descriptor Table)
```
❑ GDT可以被放在内存中的任何位置，当程序员
通过段寄存器来引用一个段描述符时，CPU必
须知道GDT的入口。Intel处理器提供了一个
GDTR寄存器，用来存放GDT的入口地址

❑ GDT放在内存中的某个位置后，使用LGDT指令
把GDT的入口地址装入GDTR，从此处理器就
依据这个寄存器中的内容作为GDT的入口来访
问GDT


## Intel保护模式下寻址总结(3)

###### ❑ GDT是保护模式所必须的数据结构，也是唯

###### 一并且对所有任务是全局可见的

###### ❑ 除了GDT之外，IA- 32 还允许程序员构建与

```
GDT类似的数据结构，即LDT(Local
Descriptor Table)。LDT不是全局可见的，只
对引用它们的任务可见。每个任务最多可以
拥有一个LDT
```
❑ 每一个LDT作为一个段存在，它们的描述符
被放在GDT中


## Intel保护模式下寻址总结(4)

###### ❑ IA- 32 为LDT的入口地址提供一个寄存器，即

###### LDTR。因为任何时刻只有一个任务运行，所

###### 以LDTR全局也只需要一个

###### ❑ 如果一个任务拥有自己的LDT，那么当它需

###### 要引用自身的LDT时，需要通过LLDT指令将

###### 其LDT对应的段描述符装入LDTR寄存器


## Intel保护模式下寻址总结(5)

###### ❑ LGDT指令和LLDT指令的不同之处在于：

```
➢ LGDT指令的操作数是一个 32 - bit的内存地址，这
个内存地址处存放的是一个 32 - bit GDT的入口地
址以及 16 - bit的GDT限界(Limit)，
➢ LLDT指令的操作数是一个 16 - bit的选择子，这个
选择子是LDT对应的段描述符在GDT中的索引。根
据该选择子，处理器从GDT中取出LDT对应的段描
述符，在进行合法性检查后，LDT段描述符的基
地址和限界等信息被装入LDTR的高速缓存寄存器
中
```

## GDT和LDT示意图

```
Dummy Descriptor
Code Descriptor
Data Descriptor
Stack Descriptor
...
LDT Descriptor 1
```
```
Code Descriptor
Data Descriptor
Stack Descriptor
```
```
GDTR
```
```
LDTR
```
###### GDT

###### LDT


## 保护之小结

###### ❑ 描述符中通过段基址和段限界定义了一个段的

###### 范围，对超越段限界之外的地址的访问是被禁

###### 止的

###### ❑ 描述符中的段属性规定和限制了段的行为和性

###### 质


## 特权级(Privilege Level)


## 特权级(Privilege Level)

❑ DPL(Descriptor Privilege Level)

❑ RPL(Requested Privilege Level)

❑ CPL(Current Privilege Level)

❑ 处理器使用特权级机制来避免低特权级的任务
在不被允许的情况下访问位于高特权级的段

❑ 如果处理器检测到一个访问请求是不合法的，
将会产生常规保护错误(GP, General Protection
Exception)


## CPL(Current Privilege Level)

###### ❑ CPL是当前执行的程序或任务的特权级。它被

###### 存储在CS和SS的第 0 位和第 1 位上

###### ❑ 通常情况下，CPL等于代码所在的段的特权级(

###### 即与该段的DPL相同)。当程序转移到不同特权

###### 级的代码段时，处理器将改变CPL


## DPL(Descriptor Privilege Level)

###### ❑ DPL表示段或者门的特权级。它定义于段描述

###### 符或者门描述符的DPL域中，它限制了可以访

###### 问此段资源的特权级别

###### ❑ 当当前代码段试图访问一个段或者门时，DPL

###### 将会和CPL以及段或门选择子的RPL比较，根据

###### 段或者门类型的不同，DPL将会被区别对待：

```
➢ 数据段：DPL规定了可以访问此段的最低特权级。
例如，一个数据段的DPL是 1 ，那么只有CPL为 0 或者
1 的程序才有权访问它
➢ 非一致代码段(不使用调用门)：DPL规定了访问此段
的特权级。例如，一个非一致代码段的DPL为 0 ，那
么只有CPL为 0 程序才可以访问它
```

## DPL(Descriptor Privilege Level)

###### ❑ 根据段或者门类型的不同，DPL将会被区别对

###### 待：

```
➢ 调用门：DPL规定了当前执行的程序或者任务可以
访问此调用门的最低特权级(与数据段规则一致)
➢ 一致代码段和通过调用门访问的非一致代码段：
DPL规定了访问此段的最高特权级。例如，一个一
致代码段的DPL为 2 ，那么CPL为 0 和 1 的程序将无法
访问此段
➢ TSS：DPL规定了访问此TSS的最低特权级(与数据段
规则一致)
```

## RPL(Requested Privilege Level)

###### ❑ RPL定义于段选择子的第 0 位和第 1 位(RPL域)，

###### 它限制了这个选择子可访问资源的最高特权级

###### ❑ 处理器通过检查RPL和CPL来确认一个访问请求

###### 是否合法


## RPL(Requested Privilege Level)

###### ❑ 例如，一个段选择子的RPL 为 2 ，那么使用这

###### 个段选择子只能访问DPL 为 2 或者 3 的段，即

###### 使使用这个段选择子的程序当前特权级(CPL)

##### 为 0 。就是说，max (CPL,RPL) ≤DPL 才被允

##### 许访问该段，即当CPL 小于RPL 时，RPL 起决

##### 定性作用，反之亦然。

###### ❑ 使用RPL 可以避免特权级高的程序代替应用程

###### 序访问该应用程序无权访问的段。例如在系统

###### 调用时，应用程序调用系统过程，虽然系统过

##### 程的特权级高(CPL = 0)，但是被调用的系统过

##### 程仍然无法访问特权级高于应用程序的段(DPL

##### < RPL = 3)，就避免了可能出现的安全问题。 36


## RPL(Requested Privilege Level)

###### ❑ 在将段描述符对应的段选择子加载到段寄存器

###### 时，处理机通过将CPL, 段选择子的RPL 和该段

###### 的DPL 相比较，来判断程序是否有权访问另外

###### 一个段

##### ❑ 如果CPL > max (RPL,DPL) ，或者max

##### (CPL,RPL) > DPL，那么该访问就是不合法的

###### ，处理机就会产生一个常规保护异常（GP，

```
General Protection Exception）
```

## 控制权转移的特权级检查

###### ❑ 在将控制权从一个代码段转移到另一个代码段

###### 之前，目标代码段的段选择子必须被加载到CS

###### 中

###### ❑ 处理器在这个过程中会查看目标代码段的段描

###### 述符，对其界限、类型和特权级进行检查。如

###### 果没有错误发生，CS 寄存器会被加载，程序

###### 控制权被转移到新的代码段，从EIP 指示的位

###### 置开始运行

###### ❑ 控制权转移可以由指令JMP, CALL, RET,

```
SYSENTER, SYSEXIT, INT n 和IRET 引起，也
可以由中断和异常机制引起
```

## 使用JMP或CALL指令转移

###### ❑ 目标操作数包含目标代码段的段选择子

###### ❑ 目标操作数指向一个包含目标代码段段选择子

###### 的调用门描述符

###### ❑ 目标操作数指向一个包含目标代码段段选择子

###### 的任务状态段(TSS)

###### ❑ 目标操作数指向一个任务门，这个任务门指向

###### 一个包含目标代码段段选择子的任务状态段

###### (TSS)


## 用JMP和CALL直接转移

###### ❑ 用JMP, CALL 和RET 指令在段内进行近跳转并

###### 没有特权级的变化，所以对这类转移是不进行

###### 特权级检查。

###### ❑ 用JMP, CALL 和RET 在段间进行远跳转涉及到

###### 其它代码段，所以要进行特权级检查


## 用JMP和CALL直接转移

###### ❑ 特权级检查分两种情形

```
➢ 访问非一致代码段：当目标是非一致代码段时，特
权级检查要求调用者的CPL 与目标代码段的DPL 相
等，而且调用者使用的目标代码段段选择子的RPL
必须小于等于目标代码段的DPL
➢ 访问一致代码段：当目标是一致代码段时，特权级
检查要求CPL ≥DPL，RPL 不被检查，而且转移时并
不修改CPL
```

## 调用门描述符


## 调用门描述符

❑ 段选择子(Segment Selector) 指定了通过这个
调用门访问的代码段

❑ 段偏移量(Offset in Segment) 指定了要访问代
码段中的某个入口偏移

❑ 描述符特权级(DPL) 代表此门描述符的特权级

❑ P代表此调用门是否可用

❑ 参数计数(Param. Count)记录了如果发生栈切
换的话，有多少个选项参数会在栈间拷贝。


## 门描述符

❑ 调用门(Call gate)

❑ 中断门(Interrupt gate)

❑ 陷阱门(Trap gate)

❑ 任务门(Task gate)

❑ 中断门和陷阱门是特殊的调用门


## 调用门实例(pmtest4.asm)

❑ 在pmtest3的基础上，增加一个代码段

❑ 通过调用门转移到这个新增的代码段

```
➢ 使用Descriptor宏构造新加代码段对应的描述符
➢ 为新增代码段描述符指定一个选择子(书上有误)
➢ 使用Gate宏构造一个调用门
➢ 为调用门指定一个选择子(即调用门的选择子)
➢ 用代码进一步初始化新增代码段的描述符
➢ 通过CALL指令完成转移
```

## 调用门作用

❑ 通过调用门和call指令，可以实现从低特权级
到高特权级的转移，无论目标代码段是一致的
还是非一致的

❑ 特权级变化时涉及到堆栈的变化，从而避免了
高特权级的过程由于栈空间不足而崩溃


## 调用门特权检查规则

###### ❑ 在使用调用门进行转移时，处理机会使用四个

###### 特权级值来检查控制权的转移是否合法：

```
➢ CPL：当前特权级
➢ RPL：调用门选择子的请求特权级
➢ DPL：调用门描述符的描述符特权级
➢ DPL：目标代码段的段描述符特权级
```

## 调用门特权检查规则

###### ❑ 使用调用门需要目标段的DPL小于或等于CPL，

###### 意思就是要转移的目标段特权级高于当前特权

###### 级(从低特权级向高特权级转移)


## 调用相关概念

###### ❑ 段内转移/段间转移、短调用/长调用

❑ Near jmp/call、Far jmp/call

❑ 通过调用门的调用往往涉及段间转移


## 短/长调用对堆栈的影响

push param1
push param2
push param3
call foo
nop
...
foo：
...
ret 3


## 短调用堆栈的变化(1)

high

```
low
```
```
ESP
```
```
第一条PUSH指令
执行之前
```
```
参数一
参数二
参数三
```
```
high
```
```
low
```
```
ESP
```
```
call指令执行之前
```

## 短调用堆栈的变化(2)

```
参数一
参数二
参数三
调用者EIP
```
```
high
```
```
low
```
```
ESP
```
```
call指令执行之后
```
```
参数一
参数二
参数三
```
high

```
low
```
```
ESP
```
```
call指令执行之前
```

## 短调用堆栈的变化(3)

```
参数一
参数二
参数三
调用者EIP
```
```
high
```
```
low
```
```
ESP
```
```
ret指令执行之后
```
```
参数一
参数二
参数三
调用者EIP
```
high

```
low
```
```
ESP
```
```
ret指令执行之前
```

## 长调用堆栈的变化(1)

high

```
low
```
```
ESP
```
```
第一条PUSH指令
执行之前
```
```
参数一
参数二
参数三
```
```
high
```
```
low
```
```
ESP
```
```
call指令执行之前
```

## 长调用堆栈的变化(2)

```
参数一
参数二
参数三
调用者CS
调用者EIP
```
```
high
```
```
low
```
```
ESP
```
```
call指令执行之后
```
```
参数一
参数二
参数三
```
high

```
low
```
```
ESP
```
```
call指令执行之前
```

## 长调用堆栈的变化(3)

```
参数一
参数二
参数三
调用者CS
调用者EIP
```
```
high
```
```
low
```
```
ESP
```
```
ret指令执行之后
```
```
参数一
参数二
参数三
调用者CS
调用者EIP
```
high

```
low
```
```
ESP
```
```
ret指令执行之前
```

## 高特权级向低特权级的转移

❑ 之前的代码一直运行在ring 0 特权级上，要实现从低
到高的转移，首先要从高特权级转到低特权级。实现
思想很简单，既然CALL 指令能从低特权级转移到高特
权级，那么RET 指令就能从高特权级返回低特权级

❑ 一般CALL 和RET 指令都是配合使用的，先用CALL 跳
转到目标地址，目标代码执行完后再用RET 返回到
CALL 的下一条指令。为了从ring 0 跳转到ring 3 ，我
们并不使用CALL 而直接执行RET。为了使RET 执行返
回时不出错，我们需要为RET 准备好返回时环境，就
像通常执行CALL 指令后处理机进行的工作一样


## 高特权级向低特权级的转移

❑ 准备好将要运行在Ring 3上的目标代码段和堆
栈段(pmtest5.asm)：将ring 3 下的目标代码段
和堆栈段的段描述符属性中加上DA_DPL3 ，
表明它们的段描述符特权级(DPL)均为 3 ；在它
们的段选择子属性中加上SA_RPL3 ，表明它们
的段选择子请求特权级(RPL)均为 3 。以上这两
点限制了这个段只能在ring 3 下运行

❑ 将这两个段的信息作为SS, ESP, CS, EIP 的内
容依次压栈，然后再执行retf长返回指令，就
能跳转到ring 3 下运行目标代码段了


## 高特权级向低特权级的转移

```
push SelectorStack3
push TopOfStack3
push SelectorCodeRing3
push 0
retf ; Ring0 -> Ring3
```

## 为执行retf进入Ring 3准备堆栈

```
目标SS
目标ESP
目标CS
目标EIP
```
```
high
```
```
low
retf指令执行之前
```
high

```
low
```
```
ESP
```
```
第一条指令执行之前
```
```
ESP
```

## 栈切换和TSS(1)

###### ❑ 当使用调用门转移到不同特权级下的非一致代

###### 码段时，处理机总会自动的切换到目标特权级

###### 对应的栈

###### ❑ 栈切换是为了避免高特权级的栈空间被滥用导

###### 致栈空间不足而崩溃，以及低特权级的程序非

###### 法修改或者干扰高特权级程序的栈内容

###### ❑ 为了使栈切换能够成功，必须为任务中用到的

###### 每个特权级都定义一个独立的栈


## 栈切换和TSS(2)

❑ 在pmtest5.asm已经定义了两个堆栈段：
LABEL STACK 和LABEL STACK3，分别被ring
0 和ring 3 使用，并且已经实现了从高特权级
转移到低特权级程序时的栈切换

❑ 从上面例子中看出，使用RET 指令时，处理机
从堆栈中得到目标特权级的堆栈段选择子
(SelectorStack3)和栈顶指针(TopOfStack3)，
然后分别存储到SS 和ESP 寄存器中，就实现
了栈切换

❑ RET 指令能如此直接地实现栈切换的关键是
CALL 指令已经将调用者所在特权级的栈信息
压到被调用者所在特权级的栈里 62


## 栈切换和TSS(3)

###### ❑ 在执行CALL 指令时，处理机不能从当前栈上

###### 获得被调用者所在特权级的栈信息，就需要一

###### 个辅助的数据结构来帮助它获得这些信息，这

```
个数据结构就是TSS(Task-State Segment, 任
务状态段) 。
```
❑ 当前任务的TSS 中存储着指向0, 1, 2 特权级栈

```
的指针，这个指针指向的内容包括一个堆栈段
选择子和栈顶指针
```

## 32 位TSS


## 32 位TSS

❑ TSS 的结构中并不包含ring 3 的栈信息，这是
因为在使用调用门时，不可能发生ring 0, 1, 2
的代码通过CALL 跳转到ring 3 的情况

❑ 返回到Ring 3的情况只会发生在RET 返回的时
候，而这时候只需要将ring 3 的栈信息压到栈
里就能实现跳转


## 堆栈切换及控制转移过程

1. 依据目标段的DPL(新的CPL)从TSS 中选择新堆栈的指
    针(堆栈段选择子和栈顶指针)
2. 从当前任务的TSS 中读取堆栈段选择子(SS)和栈顶指
    针(ESP)。在读取堆栈段选择子、栈顶指针或者堆栈段
    描述符时发生的任何错误，都会使处理机产生一个
    #TS（非法TSS）异常
3. 对堆栈段描述符进行特权级和类型检验，如果通不过
    检验处理机同样产生#TS 异常
4. 暂时保存当前SS 和ESP 寄存器中存储的堆栈段选择子
    和栈顶指针


## 堆栈切换及控制转移过程

5. 加载新的堆栈段选择子和栈顶指针到SS 和ESP中
6. 把第 4 步保存的SS 和ESP 压入新栈(被调用者栈)
7. 从旧栈(调用者栈)中复制调用门描述符中Param.
    Count 个参数到新栈中。如果PCount 为 0 ，什么都不
    复制
8. 将返回地址指针(当前CS 和EIP 寄存器中的内容)压到
    新栈中
9. 加载调用门中指定的段选择子和指令指针到CS 和EIP
    寄存器中，开始执行被调用过程


## 堆栈切换


## 跨特权级转移的返回(1)

1. 检查保存在栈上的CS 寄存器中的RPL 域看返回时是否
    需要切换特权级
2. 加载保存在被调用者栈上的CS 和EIP 寄存器信息(同时
    对段描述符和段选择子的特权级和类型进行检验)
3. 如果RET 指令有参数计数操作数，增加ESP 的值跳过
    栈上的参数部分，此时ESP 将指向保存的调用者的SS
    和ESP。RET 的参数计数操作数应与调用门中描述符中
    的PCount 域相同


## 跨特权级转移的返回(2)

4. 加载SS 和ESP，切换到调用者堆栈，被调用者的SS 和
    ESP 将被丢弃(此时会进行堆栈段选择子、栈顶指针和
    堆栈段描述符的特权级和类型检验)
5. 如果RET 指令有参数计数操作数，增加ESP 的值跳过
    栈上(调用者栈)的参数部分
6. 检查DS, ES, FS 和GS 寄存器的内容，如果某个寄存器
    指向的段的DPL 小于当前特权级CPL(此规则不适用于
    一致代码段)，该寄存器将加载一个空描述符


## 线性地址计算(Intel)

```
选择子
```
```
基地址
长度
其它域
```
```
偏移
```
```
+
```
```
32 位线性地址
```
```
选择子、偏移到线性地址的转换
```
```
描述符
```

## Intel上的分页(Paging)

```
Dir Page Offset
```
```
10 10 12
```
```
线性地址格式
```
```
...
```
1024

```
页目录
...
```
```
页表
...
```
```
页框
```
```
每个页表 1024 个表项
每个页大小为 4 K
```

## Intel上分页(Paging)


## Page Directory Entry


## Page Table Entry


## 构造页目录表和页表(pmtest6.asm)

#### ❑ 页目录表位于200000h

#### ❑ 页表位于201000h


## 进一步构造两级页表(pmtest7.asm)

#### ❑ 在实模式获得空闲内存信息

#### ❑ 显示内存空闲信息

#### ❑ 构造页目录表和页表


## 测试分页机制(pmtest8.asm)

#### ❑ 构造两个页目录表和对应的页表

#### ❑ 通过分页切换调用同一个函数


## 中断(Interrupt)

#### ❑ 中断分类 1

###### ➢外部中断

```
❑可屏蔽中断
❑不可屏蔽中断(NMI)
➢内部中断
```
#### ❑ 中断分类 2

###### ➢硬件中断

###### ➢软件中断


## 中断(Interrupt)

#### ❑ 保护模式下中断机制发生了很大变化

#### ❑ IDT(Interrupt Descriptor Table)替代了

#### IVT(Interrupt Vector Table)

#### ❑ IDT中描述符包括

```
➢中断门描述符(Interrupt Gate Descriptor)
➢陷阱门描述符(Trap Gate Descriptor)
➢任务门描述符(Task Gate Descriptor)
```

## 中断相关描述符格式


## 通过Gate转移到目标代码过程示意


## 通过Gate转移到目标代码过程

❑ Gate descriptor的selector 给出目标代码的
code segment descriptor

❑ 从目标代码code segment descriptor的base
address得出代码的 base地址

❑ 在base地址的基础上加上gate descriptor的
offset值，最终得到目标代码的入口点


## Interrupt、Trap和Exception(1)

❑ 外部中断，就是我们通常所说的中断(interrupt)
。对于执行的系统来说，这类中断的发生完全
是“异步”的，根本无法预测到此类中断会在
什么时候发生

❑ 因此，CPU(或者软件)对于此类外部中断完全是
“被动”的。不过，软件可以通过关中断的形
式来关闭对中断的响应


## Interrupt、Trap和Exception(2)

###### ❑ 通过软件产生的中断则不同，它是由专设的指

```
令，如Intel X86的“int n”，在程序中有意地
产生，所以是主动的，是“同步”的
```
❑ 只要CPU一执行一条int指令，就知道在开始执

```
行下一条指令之前一定要先进入中断服务程序
，这种主动的中断被称之为“陷阱”
```

## Interrupt、Trap和Exception(3)

###### ❑ 还有一种与中断相似的机制称之为“异常

```
”(exception)，一般也是异步的，多半是由于
“不小心”犯了规才发生的。例如，当在程序
中发出一条除法指令div，而除数为零时就会发
生一次异常
```
❑ 异常的发生多半是由于不小心，而不是故意的
，所以这也是被动的


## 保护模式下的中断示例

❑ pmtest9.asm


## 保护模式下的I/O

❑ 指令in、ins、out、outs、cli和sti被称为I/O敏
感指令(I/O Sensitive Instructions)

❑ 只有在CPL≤IOPL时才能执行

❑ 可以改变IOPL的指令只有popf和iretd，但只有
运行在Ring 0的程序才能将其改变


## POPF/POPFD

❑ POPF/POPFD pops the word or doubleword
on the top of the stack and stores the value
in the flags register

❑ If the operand-size attribute of the instruction
is 16 bits, then a word is popped and the
value is stored in FLAGS. If the operand-size
attribute is 32 bits, then a doubleword is
popped and the value is stored in EFLAGS.


## IRETD/RET/RETF

❑ RET, and its exact synonym RET N, pop IP or
EIP from the stack and transfer control to the
new address

❑ RETF executes a far return: after popping
IP/EIP, it then pops CS, and then increments
the stack pointer by the optional argument if
present

❑ IRET returns from an interrupt (hardware or
software) by means of popping IP (or EIP),
CS and the flags off the stack and then
continuing execution from the new CS:IP


## IRETD RET RETF

❑ IRETW pops IP, CS and the flags as 2 bytes
each, taking 6 bytes off the stack in total

❑ IRETD pops EIP as 4 bytes, pops a further 4
bytes of which the top two are discarded and
the bottom two go into CS, and pops the
flags as 4 bytes as well, taking 12 bytes off
the stack

❑ IRET is a shorthand for either IRETW or
IRETD, depending on the default BITS setting
at the time


## EFLAGS Register


## I/O许可位图

#### ❑ I/O Permission Bitmap

#### ❑ 0 - 端口可用

#### ❑ 1 - 端口不可用


## I/O许可位图

```
[SECTION .tss3]
LABEL_TSS3:
...
DD SELECTORLDT3 ;LDT
DW 0 ;调试陷阱标志
DW $- LABEL_TSS3 + 2;指向I/O许可位图
times 12 DB 0FFh ;端口 00 - 5fh
DB 11111101b ;端口 60 - 67h，61h允许
DB 0ffh ;I/O许可位图结束标志
TSS3LEN EQU $ - LABEL_TSS3
```

## 鲲鹏处理器

❑ 鲲鹏处理器是基于ARMv8- 64 指令集开发的通用处
理器；CPU有很多指令集架构，最流行的就是Intel
的x86，在手机端占据统治地位的ARM等。从历史
的发展来看，ARM的算力从 2000 年的不到5%，
发展到现在82%，非常迅速

❑ 鲲鹏处理器的相关概念

```
➢ DIE - 芯片的最小物理单元。Kunpeng 920封装了 3 个
DIE，两个用来做计算，第三个用来做IO
➢ Cluster – 若干个核(core)的集合。Kunpeng 920把 4 个
core集合成为一个cluster，而一个DIE上有 8 个cluster
➢ Core - 真正的计算单元，在操作系统侧看到的“核”
```

## 鲲鹏处理器


## 鲲鹏处理器


