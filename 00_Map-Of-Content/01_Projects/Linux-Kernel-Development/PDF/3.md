# ELF文件格式

## Chapter 02


ELF文件格式概述 (1)

❑ In computing, the Executable and Linkable

Format (ELF, formerly called Extensible

Linking Format) is a common standard file

format for executables, object code, shared

libraries, and core dumps. First published in

the System V Application Binary Interface

specification, and later in the Tool Interface

Standard, it was quickly accepted among

different vendors of Unix systems. In 1999 it

was chosen as the standard binary file format

for Unix and Unix-like systems on x86 by

the 86open project


ELF文件格式概述 (2)

❑ Unlike many proprietary executable file

formats, ELF is very flexible and extensible,

and it is not bound to any particular

processor or architecture. This has allowed it

to be adopted by many different operating

systems on many different platforms


ELF File Layout (1)

❑ Each ELF file is made up of one ELF header,

followed by file data. The file data can

include:

➢ Program header table(程序头表), describing zero

or more segments(段)

➢ Section header table(节头表), describing zero or

more sections(节)

➢ Data referred to by entries in the program header

table or section header table


ELF File Layout (2)

❑ The segments contain information that is

necessary for runtime execution of the file,

while sections contain important data for

linking and relocation.

❑ Any byte in the entire file can be owned by a

section (and never more than one section),

and there can be orphan bytes which are not

owned by a section


ELF File Layout (3)


ELF File Layout (4)


样例程序foo.asm (1)

extern choose ; int choose(int a, int b);
[section .data] ; 数据在此
num1st dd 3
num2nd dd 4
[section .text] ; 代码在此
global _start ; 必须导出 _start 这个入口，以便让链接器识别。
global myprint ; 导出这个函数为了让 bar.c 使用
_start:
push num2nd ; ┓
push num1st ; ┃
call choose ; ┣choose(num1st, num2nd);
add esp, 4 ; ┛
mov ebx, 0
mov eax, 1 ; sys_exit
int 0x80 ; 系统调用

; void myprint(char* msg, int len)
myprint:
mov edx, [esp + 8] ; len
mov ecx, [esp + 4] ; msg
mov ebx, 1
mov eax, 4 ; sys_write
int 0x80 ; 系统调用
ret


样例程序bar.c (2)

void myprint(char* msg, int len);

int choose(int a, int b)
{
if(a >= b){
myprint("the 1st one\n", 13);
}
else{
myprint("the 2nd one\n", 13);
}

return 0;
}


样例程序编译方法

[root@XXX XXX]# nasm -f elf foo.asm -o foo.o

[root@XXX XXX]# gcc -c bar.c -o bar.o

[root@XXX XXX]# ld -s foo.o bar.o -o foobar

[root@XXX XXX]# ./foobar

the 2nd one

[root@XXX XXX]#

(ld 的‘-s’选项意为“strip all”)


ELF中的常用数据类型

名称 大小 对齐 目的

Elf32_Addr 4 4 无符号程序地址

Elf32_Half 2 2 无符号中等大小整数

Elf32_Off 4 4 无符号文件偏移

Elf32_SWord 4 4 有符号大整数

Elf32_Word 4 4 无符号大整数

unsigned char 1 1 无符号小整数


ELF Header数据结构

#define EI_NIDENT 16

typedef struct{

```
unsigned char e_ident[EI_NIDENT];
Elf32_Half e_type;
Elf32_Half e_machine;
Elf32_Word e_version;
Elf32_Addr e_entry;
Elf32_Off e_phoff;
Elf32_Off e_shoff;
Elf32_Word e_flags;
Elf32_Half e_ehsize;
Elf32_Half e_phentsize;
Elf32_Half e_phnum;
Elf32_Half e_shentsize;
Elf32_Half e_shnum;
Elf32_Half e_shstrndx;
```
}Elf32_Ehdr;


ELF Header的各字段含义


ELF Header的各字段含义


Foobar中的ELF Header

名称 值 解释

e_type 0x0002 表示为可执行文件

e_machine 0x0003 运行需要的体系结构为Intel

e_version 0x00000001 文件版本

e_entry 0x08048080 程序入口地址

e_phoff 0x00000034 程序头表在文件中的偏移

e_shoff 0x00000198 节头表在文件中的偏移

e_flags 0x00000000 对IA32来说，此项为 0

e_ehsize 0x0034 ELF Header大小

e_phentsize 0x0020 程序头表中每个表项的大小

e_phnum 0x0002 程序头表中表项的数目

e_shentsize 0x0028 节头表中每个表项的大小

e_shnum 0x0007 节头表中表项的数目

e_shstrndx 0x0006 包含节名称的字符串表是第几个节


Program Header数据结构

typedef struct {

Elf32_Word p_type; //当前Program Header所描述段的类型

Elf32_Off p_offset; //段的第一个字节在文件中偏移

Elf32_Addr p_vaddr; //段的第一个字节的虚拟地址

Elf32_Addr p_paddr; //在物理地址定位相关的系统中，此项为物理地址保留

Elf32_Word p_filesz; //段在文件中长度

Elf32_Word p_memsz; //段在内存中长度

Elf32_Word p_flags; //与段相关的标志

Elf32_Word p_align; //确定段在文件以及内存中如何对齐

} Elf32_Phdr;


## Foobar中的Program Header

   - 名称 Program header^0 Programheader
- p_type 0x00000001 0x
- p_offset 0x00000000 0x
- p_vaddr 0x08048000 0x
- p_paddr 0x08048000 0x
- p_filesz 0x0000000d 0x
- p_memsz 0x0000010d 0x
- p_flags 0x00000005 0x
- p_align 0x00001000 0x


Section Header数据结构

typedef struct{

```
Elf32_Word sh_name;
Elf32_Word sh_type;
Elf32_Word sh_flags;
Elf32_Addr sh_addr;
Elf32_Off sh_offset;
Elf32_Word sh_size;
Elf32_Word sh_link;
Elf32_Word sh_info;
Elf32_Word sh_addralign;
Elf32_Word sh_entsize;
```
}Elf32_Shdr;


从Loader到内核

❑ 加载内核（Kernel）到内存

❑ 跳入保护模式


用Loader加载ELF(/chapter5/c)

❑ Loader加载内核（Kernel）的过程和引导扇区

加载Loader的过程相似

➢ 在磁盘上寻找文件、定位文件以及读入内存

❑ 参见/chapter5/c


/chapter5/c目录下kernel.asm

### ; 编译链接方法

; $ nasm -f elf kernel.asm -o kernel.o
; $ ld -s kernel.o -o kernel.bin #‘-s’选项意为“strip all”

[section .text] ; 代码在此

global _start ; 导出 _start

_start: ; 跳到这里来的时候，我们假设 gs 指向显存
mov ah, 0Fh ; 0000: 黑底 1111: 白字
mov al, 'K'
mov [gs:((80 * 1 + 39) * 2)], ax ; 屏幕第 1 行, 第 39 列
jmp $


/chapter5/c目录下kernel.asm

### ; 编译链接方法

; $ nasm -f elf kernel.asm -o kernel.o
; $ ld -s kernel.o -o kernel.bin #‘-s’选项意为“strip all”

[section .text] ; 代码在此

global _start ; 导出 _start

_start: ; 跳到这里来的时候，我们假设 gs 指向显存
mov ah, 0Fh ; 0000: 黑底 1111: 白字
mov al, 'K'
mov [gs:((80 * 1 + 39) * 2)], ax ; 屏幕第 1 行, 第 39 列
jmp $


跳入保护模式(/chapter5/d)

❑ 构造GDT，加入转入保护模式的相关代码

❑ 进入保护模式显示内存信息(DispMemInfo)、

构造页目录表和页表(SetupPaging)

❑ 参见/chapter5/d（进入保护模式没有做太多事

情）


重新放置内核(/chapter5/e)

❑ 内核文件(对应的源代码为kernal.asm)已经被

读入内容，并且放在了80000h开始的内存区域

❑ 根据内核文件（ELF格式）格式信息，重新放

置内核到30000h开始的内存区域

❑ 参见/chapter5/e


/chapter5/e目录下kernel.asm

### ; 编译链接方法

; [root@XXX XXX]# nasm -f elf kernel.asm -o kernel.o
; [root@XXX XXX]# ld -s -Ttext 0x30400 -o kernel.bin kernel.o
; [root@XXX XXX]#

[section .text] ; 代码在此

global _start ; 导出 _start

_start: ; 跳到这里来的时候，我们假设 gs 指向显存
mov ah, 0Fh ; 0000: 黑底 1111: 白字
mov al, 'K'
mov [gs:((80 * 1 + 39) * 2)], ax ; 屏幕第 1 行, 第 39 列
jmp $


kernel.bin的ELF Header

名称 值 解释

e_type 0x0002 表示为可执行文件

e_machine 0x0003 80386

e_version 0x00000001 文件版本

e_entry 0x00030400 程序入口地址

e_phoff 0x00000034 程序头表在文件中的偏移

e_shoff 0x00000448 节头表在文件中的偏移

e_flags 0x00000000 对IA32来说，此项为 0

e_ehsize 0x0034 ELF Header大小

e_phentsize 0x0020 程序头表中每个表项的大小

e_phnum 0x0001 程序头表中表项的数目

e_shentsize 0x0028 节头表中每个表项的大小

e_shnum 0x0004 节头表中表项的数目

e_shstrndx 0x0003 包含节名称的字符串表是第几个节


kernel.bin的Program Header

名称 值 说明

p_type 0x00000001 PT_LOAD

p_offset 0x00000000 段的第一个字节在文件中偏移

p_vaddr 0x00030000 段的第一个字节的虚拟地址

p_paddr 0x00030000

p_filesz 0x0000040d 段在文件中的长度

p_memsz 0x0000040d 段在内存中的长度

p_flags 0x00000005

p_align 0x00001000


装入Kernel.bin之后的内存布局

**...**

Page Tables

Page Directory Table

Hardware Reserved

LOADER.BIN

KERNEL.BIN

整理后的KERNEL

...

30000h

0h

90000h

80000h

100000h

9fc000h

101000h

← cs, ds, es, fs, ss

somewhere in LOADER ← esp

30400h ← KERNEL 入口 (KernelEntryPointPhyAddr)

PageDirBase = 1M

B8000h ← gs

PageTblBase


切换堆栈和GDT (/chapter5/f)

❑ GDT及SELECTOR的结构

DESC_VIDEO

DESC_FLAT_RW (0～4G)

DESC_FLAT_C (0～4G)

Dummy Descriptor

8h =cs

10h=ds, es, ss, fs

1bh=gs

Descriptors Selectors


Makefile的作用(/chapter5/f)

❑ 当有多个源程序时，重复地输入编译、链接命

令非常麻烦

❑ 在Makefile中指明可执行文件、中间目标文件

和源程序文件之间依赖关系，使用make工具

可以方便完成编译


Makefile示例

# Makefile for boot
# Programs, flags, etc.
ASM = nasm
ASMFLAGS =

# This Program
TARGET = boot.bin loader.bin

# All Phony Targets
.PHONY : everything clean all

# Default starting position
everything : $(TARGET)

clean :
rm -f $(TARGET)

all : clean everything

boot.bin : boot.asm ./include/load.inc ./include/fat12hdr.inc
$(ASM) $(ASMFLAGS) -o $@ $<

loader.bin : loader.asm ./include/load.inc ./include/fat12hdr.inc ./include/pm.inc
$(ASM) $(ASMFLAGS) -o $@ $< 31


Makefile文件内容解释(P150-154)

#开始为注释

=用来定义变量

target : prerequisites

command

everything, clean, all表示动作

$@代表target

$<代表prerequisites中的第一个名字


目录结构的整理(/chapter5/g)

| --a.img
| --bochsrc
| --boot
| |--boot.asm
| | --include
| | |--fat12hdr.inc
| | |--load.inc
| | |--pm.inc
| |--loader.asm
| --include
| |--const.h
| |--protect.h
| |--type.h
| --kernel
| |--kernel.asm
| |--start.c
| --lib
|--kliba.asm
|--string.asm


添加中断、异常处理(/chapter5/h)

❑ 初始化 8259 控制器

❑ 编写异常处理程序

❑ 编写中断处理程序

❑ 构造IDT


实验作业 1

❑ 在openEuler操作系统上，通过独立命令行编

译foo.asm和bar.c，链接得到可执行文件

foobar，并通过相关工具查看foobar的结构

❑ 在openEuler操作系统上，编写makefile文件，

以便通过make编译可执行文件foobar


