---
tags:
  - Knowledge/computer-science/CSAPP
created: 2025-10-21
author:
  - ln1
status: Done
---
## 1.程序编码：
### 1.1.机器级代码：
对于机器级编程来说，两种抽象最为重要：
- **指令集体系结构或指令集架构**（Instruction Set Architecture,ISA);
- 机器级程序使用的内存地址是虚拟地址。
程序计数器（PC）给出将要执行的下一条指令在内存中的地址。
**程序内存**包括：程序的可执行机器代码，操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、用户分配的内存块。
>链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置。
### 1.2.格式的注解
以'.'开头的行都是指导汇编器和链接器工作的伪指令。![[Pasted image 20251021232906.png]]
为了访问机器的低级特性，必须使用汇编代码：
- 编写整个程序
- 在C程序中嵌入汇编代码
### 1.3.数据格式：
> 由于是从16位体系结构扩展为32位的，Intel用术语“字（word）“表示16位数据类型。

![[Pasted image 20251022194325.png]]
### 1.4.访问信息：
![[Pasted image 20251022194916.png]]
生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。
### 4.1.操作数指示符：
操作数分为3类：
- 立即数（immediate）
- 寄存器（register）
- 内存引用![[Pasted image 20251022195230.png]]
### 4.2.数据传送指令：
`MOV`:两个操作数不能都指向内存位置。
- 大多数情况下，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。
- 唯一的例外是**movl**指令以**寄存器**作为目的时，它会把该寄存器的高位4位设置为0。
`MOVZ`:会把剩余字节填充为0；
`MOVZ`:会把剩余字节符号扩展来填充。
### 4.3.数据传送示例：
![[Pasted image 20251022200322.png]]
### 4.4.压入和弹出栈数据：
> 栈顶元素的地址是所有栈中元素地址中最低的。

弹出一个四字操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令`popq %rax`等价下面两条指令：
```asm
movq (%rsp),%rax
addq %8,%rsp
```

## 5.算术和逻辑操作
### 5.1.加载有效地址：
load effective address指令leaq实际上是movq指令的变形。
- 从内存读数据到寄存器，但实际上它根本就没有引用内存。
- 实际上是 **将有效地址写入到目的操作数**。
### 5.2.一元和二元操作：
#### 两种主要语法
- Intel 语法：常见于 Windows、MASM、TASM、Visual Studio  
- AT&T 语法：常见于 Unix/Linux、GCC、GAS（GNU Assembler）
#### 操作数顺序区别
- Intel 语法：`mov 目标, 源`
- AT&T 语法：`mov 源, 目标`
- 实际含义相同，都是“目标 ← 源”，但书写顺序相反
### 5.3.移位操作：
左移：SAL和SHL，两者的效果一样。都是将右边填上0.
右移：
- SAR执行算术移位（填上符号位）
- SHR执行的是逻辑移位（填上0）
### 5.4.特殊的算术操作：
![[Pasted image 20251022203116.png]]
要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。
然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。
## 6.控制
用jump指令可以改变一组机器代码指令的执行顺序。
[[LKA-week-6]]
### 6.1.条件码：
condition code
- CF：进位标志
- ZF：零标志
- SF：符号标志
- OF：溢出标志
![[Pasted image 20251026195649.png]]
- 除了只设置条件码而不改变任何其他寄存器之外，CMP指令与SUB指令的行为是一样的。
- TEST指令的行为和AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。
### 6.2.访问条件码：
一条SET指令的目的操作数是低位单字节寄存器元素之一。
![[Pasted image 20251026202718.png]]
```asm
comp:
	cmpq    %rsi,%rdi
	setl    %al
	movzbl  %al,%eax
	ret
```
机器代码不会将每个程序值都和一个数据类型联系起来。
- 大多数情况下，机器代码对于有符号和无符号两种情况都使用一样的指令。，许多算术运算对无符号和补码算术都有一样的位级行为。
### 6.3.跳转指令：
跳转（jump）的目的地通常用一个**标号**（label）指明。![[Pasted image 20251026204317.png]]
- 跳转指令有几种不同的编码，最常用的是PC相对的（PC-relative）。
- 第二种编码方法是给出“绝对”地址，用4个字节直接指定目标。
在执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。
### 6.4.用条件控制来实现条件分支：
- 有条件跳转
- 无条件跳转
### 6.5.用条件传送来实现条件分支：
- 问题就是**条件控制**不便于利用CPU的流水线（pipeline）等机制加速运行，因此在现代处理器上，它可能会非常低效。
- 此时我们引入了数据等条件转移：计算一个条件操作的两种结果，**然后再根据条件是否满足从中选取一个**。
- 然而不是所有的条件表达式都可以用条件传送来编译，如果两个表达判别式中的任意一个可能产生错误条件或者副作用，就会导致非法行为：例如如果除数不是0才除，如果两者都提前进行就将引入错误。
- **条件传送也不总是会提高代码的效率**。
### 6.6.循环：
#### 1.do-while循环：
```asm
loop:
	body-statement
	t = test-expr
	if(t)
		goto loop;
```
显然这种非常契合汇编实现和机器层次的实现。
#### 2.while循环：
1. **跳转到中间（jump to middle)**:
```asm
	goto test;
loop:
	body-statement
test:
	t = test-expr;
	if(t)
		goto loop;
```
先跳转到测试部分，然后再测试是否满足要求返回到主体部分。
2. **guarded-do**
首先使用条件分支，如果初始条件不成立就跳过循环，把代码变换成do-while循环。
```asm
t = test-expr;
if(!t)
	goto done;
do
	body-statement
	while(test-expr);
done:
```
利用这种实现策略：编译器通常可以优化初始的测试，例如认为测试条件总是满足。
#### 3.for循环：
```C
for(init-expr;test-expr;update-expr)
	body-statement
```
约等于
```C
init-expr;
while(test-expr){
	body-statement
	update-expr;
}
```
然后接下来是对于`while`的两种翻译。
### 6.7.switch语句
执行switch语句的关键步骤是通过跳转表来访问代码位置。
## 7.过程
 - 传递控制。
 - 传递数据。
 - 分配和释放内存。
### 7.1.运行时栈：
当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个空间被称为过程的**栈帧**(stack fram)。
- 通过寄存器，过程传递最多6个整数值(也就是指针和整数)
- 如果需要更多的参数，P可以调用Q之前在自己的栈帧里存储好这些参数。
![[Pasted image 20251029222812.png]]
### 7.2.转移控制：
- 使用call Q调用过程Q来记录：把caller的下一条地址A压入栈中，并将PC设置为callee的起始地址。
- 使用ret弹出caller的地址A，并把PC设置为A。
### 7.3.数据传送：
把数据作为参数传递。
### 7.4.栈上的局部存储：
有些时候，局部数据必须存放在内存中，常见的情况包括：
- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用地址运算符‘&’，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够数组或结构引用被访问到。
### 7.5.寄存器中的局部存储空间：
必须确保当一个过程（caller）调用另一个过程（callee）时，callee不会覆盖调用者稍后会使用的寄存器值。
- **调用者保存寄存器**：过程P调用过程Q，Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P（caller）的责任。
- **被调用者保存寄存器**：当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时时一样的。　
### 7.6.递归过程：
![[Pasted image 20251029225304.png]]
## 8.数据分配和访问：
### 8.1.基本原则：
![[Pasted image 20251029225746.png]]
### 8.2.指针运算：
![[Pasted image 20251029225937.png]]
### 8.3.嵌套的数组：
对于一个声明如下的数组：
`T D[R][C]`
它的数组元素`D[i][j]`的内存地址为：
$$ \&D[i][j] = x_D + L(C*i+j)$$
![[Pasted image 20251029230713.png]]
### 8.4.定长数组：
当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过#define 声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。
### 8.5.变长数组：
数组的维度时表达式，在数组被分配到时候才计算出来。
- 如果允许使用优化，GCC能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式会导致的乘法。
## 9.异质的数据结构：
- 结构（structure），用关键字struct来声明，将多个对象集合到一个单位中；
- 联合（union）：用关键字union来声明，允许用几种不同的类型来引用一个对象。
### 9.1.结构：
```C
struct rec{
	int i;
	int j;
	int a[2];
	int *p;
};
```
![[Pasted image 20251030161458.png]]
### 9.2.联合：
```C
union U3{
	char c;
	int i[2];
	double v;
};
```
提供了一种方式，允许以多种类型来引用一个对象。
### 9.3.数据对齐：
为了满足某些计算机系统对数据类型的合法地址做出的要求某种类型对象的地址必须是某个值K的倍数的限制。
## 10.在机器级程序中将控制与数据结合起来
### 10.1.理解指针
- 每个指针都对应一个类型。
- 每个指针都有一个值。
- 指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。
- **指针也可以指向函数**：
  函数指针是指向函数的指针变量，它存储的是函数的地址。在机器级别，函数名实际上就是函数代码在内存中的起始地址。
  
  **函数指针的声明语法**：
  ```c
  返回类型 (*指针名)(参数类型列表);
  ```
  
  **基本示例**：
  ```c
  #include <stdio.h>
  
  // 定义两个简单的函数
  int add(int a, int b) {
      return a + b;
  }
  
  int multiply(int a, int b) {
      return a * b;
  }
  
  int main() {
      // 声明函数指针
      int (*operation)(int, int);
      
      // 指向add函数
      operation = add;  // 或者 operation = &add;
      printf("5 + 3 = %d\n", operation(5, 3));
      
      // 指向multiply函数
      operation = multiply;
      printf("5 * 3 = %d\n", operation(5, 3));
      
      return 0;
  }
  ```
  
  **函数指针数组示例**：
  ```c
  #include <stdio.h>
  
  int add(int a, int b) { return a + b; }
  int sub(int a, int b) { return a - b; }
  int mul(int a, int b) { return a * b; }
  int div(int a, int b) { return a / b; }
  
  int main() {
      // 函数指针数组
      int (*operations[4])(int, int) = {add, sub, mul, div};
      char symbols[] = {'+', '-', '*', '/'};
      
      int a = 10, b = 5;
      
      for (int i = 0; i < 4; i++) {
          printf("%d %c %d = %d\n", a, symbols[i], b, operations[i](a, b));
      }
      
      return 0;
  }
  ```
  
  **回调函数示例**：
  
  **本质**：回调函数就是一个"占位符"机制。主函数预留一个位置，具体要执行什么操作由传入的函数决定。
  
  ```c
  #include <stdio.h>
  
  typedef void (*callback_t)(int);
  
  void print_square(int x) { printf("Square: %d\n", x * x); }
  void print_double(int x) { printf("Double: %d\n", x * 2); }
  
  // 主函数：处理数组，具体操作由callback决定
  void process_array(int arr[], int size, callback_t callback) {
      for (int i = 0; i < size; i++) {
          callback(arr[i]);  // 占位符：调用传入的函数
      }
  }
  
  int main() {
      int numbers[] = {1, 2, 3};
      
      process_array(numbers, 3, print_square);  // 占位符填入"平方"操作
      process_array(numbers, 3, print_double);  // 占位符填入"双倍"操作
      
      return 0;
  }
  ```
  
  **关键理解**：`process_array`不知道要对数组元素做什么，它只是提供一个框架，具体操作通过函数指针参数"填入"。
  
  **机器级别的理解**：
  在汇编层面，函数指针实际上就是一个存储函数地址的内存位置：
  ```asm
  # 假设有函数指针 int (*fp)(int, int) = add;
  # 调用 fp(5, 3) 的汇编代码类似于：
  movl    $5, %edi        # 第一个参数
  movl    $3, %esi        # 第二个参数
  callq   *%rax           # 间接调用，%rax存储函数地址
  ```
  
  **函数指针的应用场景**：
  - 回调函数机制
  - 状态机实现
  - 插件系统
  - 事件处理系统
  - 算法策略模式
  - 虚函数表（C++中的多态实现基础）
### 10.2.GDB调试器：

GDB（GNU Debugger）是分析机器级程序的强大工具，可以观察程序的运行时行为。

**编译调试版本**：
```bash
gcc -Og -g -o prog prog.c  # -g生成调试信息，-Og优化级别适合调试
```

**常用GDB命令**：
- `gdb prog` - 启动调试器
- `break main` - 在main函数设置断点
- `run` - 运行程序
- `stepi` - 执行一条机器指令
- `nexti` - 执行下一条指令（不进入函数调用）
- `continue` - 继续执行到下一个断点
- `print $rax` - 查看寄存器rax的值
- `print /x $rsp` - 以十六进制显示栈指针
- `x/8xg $rsp` - 查看栈顶8个8字节的内容
- `disas` - 反汇编当前函数
- `info registers` - 显示所有寄存器状态
- `backtrace` - 显示函数调用栈

**调试示例**：
```bash
(gdb) break main
(gdb) run
(gdb) stepi           # 单步执行机器指令
(gdb) print $rdi      # 查看第一个参数寄存器
(gdb) x/4xw $rsp      # 查看栈顶4个字的内容
```

**机器级调试的价值**：
- 理解编译器如何将C代码转换为汇编
- 观察函数调用、参数传递、栈帧变化
- 分析程序崩溃的根本原因
- 验证对机器级代码的理解
### 10.3.内存越界引用和缓冲区溢出：
C对数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。
会导致两种破坏：
- 缓冲区溢出(buffer overflow)
- 通过攻击代码(exploit code)**让程序执行它原本不愿意执行的函数**。
蠕虫和病毒的区别：
- 蠕虫(worm):可以**自己运行**，并且能够将自己的等效副本传播到其他机器。
- 病毒(virus):能够将自己的代码注入(inject)到其他程序，但**不能独立运行**。
### 10.4.对抗缓冲区溢出攻击：
1. 栈随机化：使得栈的位置在程序每次运行时都有变化。更大的一类技术：*地址空间布局随机化*(Address-Space Layout Randomization) 常见的把戏：nop 来利用蛮力克服随机化。
2. 栈破坏检测：金丝雀（canary）值。
3. 限制可执行代码区域。
以上操作都：不需要程序员做任何特殊的努力，带来的性能代价都非常小。
### 10.5.支持可变栈帧：

**什么是可变栈帧？**
大多数函数的栈帧大小在编译时就能确定，但有些情况下栈帧大小只能在运行时确定，这就需要可变栈帧。

**需要可变栈帧的情况**：
1. **变长数组（VLA）**：数组大小由运行时变量决定
2. **alloca()函数**：在栈上动态分配内存
3. **可变参数函数**：参数数量不固定

**帧指针的作用**：
- **%rbp寄存器**：作为帧指针，指向当前栈帧的固定位置
- **为什么需要**：当栈帧大小可变时，无法用固定偏移量访问局部变量
- **解决方案**：用帧指针作为参考点，通过固定偏移访问变量

**可变栈帧示例**：
```c
// 变长数组示例
long vframe(long n, long idx, long *q) {
    long i;
    long *p[n];          // 指针数组：n个指针，每个指针8字节
    p[0] = &i;
    for (i = 1; i < n; i++)
        p[i] = q;
    return *p[idx];
}
```

**为什么是 `long *p[n]` 而不是 `long p[n]`？**

两者的区别：
- `long p[n]`：长整型数组，需要 n × 8 字节空间
- `long *p[n]`：指针数组，需要 n × 8 字节空间（每个指针8字节）

**关键在于使用方式**：
```c
// 如果是 long p[n]:
long p[n];
p[0] = 123;        // 直接存储long值
return p[idx];     // 直接返回long值

// 实际代码 long *p[n]:
long *p[n];
p[0] = &i;         // 存储指针（地址）
return *p[idx];    // 解引用指针，返回指针指向的值
```

**为什么选择指针数组**：
1. **演示指针操作**：展示如何在栈上存储和操作指针
2. **内存访问模式**：通过指针间接访问数据，更复杂的内存布局
3. **实际应用场景**：很多实际程序确实需要指针数组来管理不同位置的数据

**两种方案的栈空间需求都一样**：
- `long p[n]`：n × 8字节（存储n个long值）
- `long *p[n]`：n × 8字节（存储n个指针）

所以从演示可变栈帧的角度，两者效果相同，但指针数组更能体现C语言的指针特性。

**对应的汇编代码结构**：
```asm
vframe:
    pushq   %rbp        # 保存旧的帧指针
    movq    %rsp, %rbp  # 设置新的帧指针
    subq    $16, %rsp   # 为局部变量分配固定空间
    leaq    22(,%rdi,8), %rax  # 计算变长数组需要的空间
    andq    $-16, %rax  # 对齐到16字节边界
    subq    %rax, %rsp  # 在栈上分配变长数组空间
    # ... 函数体 ...
    leave               # 等价于 movq %rbp, %rsp; popq %rbp
    ret
```

**栈帧布局对比**：

**固定栈帧**：
```
高地址
+----------------+
| 返回地址       |
+----------------+
| 局部变量       | <- %rsp + 固定偏移
+----------------+
| ...            |
+----------------+ <- %rsp
低地址
```

**可变栈帧**：
```
高地址
+----------------+
| 返回地址       |
+----------------+
| 保存的%rbp     | <- %rbp指向这里
+----------------+
| 局部变量       | <- %rbp - 固定偏移
+----------------+
| 变长数组       | <- 大小运行时确定
+----------------+ <- %rsp（位置不固定）
低地址
```

**关键理解**：
- **固定栈帧**：可以用%rsp + 偏移量访问所有变量
- **可变栈帧**：必须用%rbp作为基准，因为%rsp位置不固定
- **性能代价**：需要额外的帧指针寄存器，稍微降低性能
- **现代编译器**：只在必要时才使用帧指针，大多数情况下仍使用固定栈帧
## 11.符点代码：
处理器的 **浮点体系结构**（floating-point architecture）主要指的是：
- 浮点数在机器中**如何存储**；
- **浮点运算指令**怎么设计；    
- **函数调用时浮点参数如何传递**、结果如何返回；
- **哪些寄存器谁负责保存**（调用者 or 被调用者）。
### 11.1.浮点传送和转换操作：
![[Pasted image 20251105170209.png]]
GCC只用标量传送操作从内存传送数据到XMM寄存器或从XMM寄存器传送数据到内存。
对于在两个XMM寄存器之间传送数据，GCC会使用两种指令之一，即用**vmovaps**传送单精度数，用**vmovapd**传送双精度数。![[Pasted image 20251105171455.png]]
### 11.2.过程中的浮点代码：
- XMM寄存器%xmm0~%xmm7最多可以**传递8个**浮点参数，可以通过**栈传递额外**的浮点参数。
- 函数使用寄存器%xmm0来返回浮点值。
- 所有的XMM寄存器都是**调用者保存**的。被调用者可以不用保存就覆盖这些寄存器。
### 11.3.浮点运算操作：
![[Pasted image 20251105174158.png]]
- 第一个源操作数$S_1$可以是一个XMM寄存器或一个内存位置。
- 第二个源操作数$S_2$和目的操作数都必须是XMM寄存器。
### 11.4.定义和使用浮点常数
AVX浮点常数不能以立即数值作为操作数。编译器必须为所有的常量值分配和初始化存储空间。![[Pasted image 20251105175851.png]]
### 11.5.在浮点代码中使用位级操作
![[Pasted image 20251105180050.png]]
### 11.6.浮点比较操作
![[Pasted image 20251105180331.png]]
浮点比较指令会设置三个条件码：**零标志位 ZF** 、**进位标志位 CF** 和**奇偶标志位 PF** 。
对于浮点比较，当两个操作数中任一个是NaN 时，会设置奇偶校验位PF。
> 会产生一个很神奇的现象，即一个数可以大于0 小于0 等于0 还可以是其他的数(不是一个数NaN）。


![[Pasted image 20251105180557.png]]
![[Pasted image 20251105180749.png]]
