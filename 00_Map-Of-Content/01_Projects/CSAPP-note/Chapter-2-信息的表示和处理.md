---
tags:
  - Knowledge/computer-science/CSAPP
  - Knowledge/Algorithm/Bitwise-Operations
created: 2025-09-17
author:
  - ln1
status: Done
---
为了使编写的程序能**在全部数值范围内正确工作**，而且具有可以跨越不同机器、操作系统和编译器组合的**可移植性**。
- 无符号(unsigned)编码基于传统的二进制表示法，表示大于或者等于零的数字；
- 补码(two's-complement)编码是表示有符号证书的最常见的方式；
- 浮点数(floating-point)编码是表示实数的方法。
## 1.信息存储
字节(byte)：8位(bit)
### 1.1.十六进制表示法
二进制表示法太冗长，而十进制表示法与位模式的相互转化很麻烦。
- 0x或0X开头的数字常量被认为是十六进制的值。
### 1.2.字数据大小
**字长(word size)**:指明一台计算机指针数据的标称大小(normal size)。
- 大多数64位机器可以运行32位机器编译的程序，**向后兼容**。
- 64位程序则只能在64位机器上执行。
- ISO C99引入了：**int32_t**和**int64_t**分别位4个字节和8个字节。
程序员应该力图使他们的程序在不同的机器和编译器上**可移植**，可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。
### 1.3.寻址和字节顺序
- 小端法(little endian)：最低有效字节在最前面的方法：
![[Pasted image 20250917203103.png]]
- 大端法(big endian)：最高有效字节在最前面的方法：
![[Pasted image 20250917203315.png]]
> 十六进制数：0x01234567

- 大多数Intel兼容机都只用小端模式
- 比较新的微处理器使用双端法(bi-endian)
- 一旦选择了特定操作系统，那么字节顺序也就固定下来。
### 1.4.表示字符串
- C语言中字符串被编码为一个**以null(值为0)字符结尾**的字符数组。
- 在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关，因而**文本数据比二进制数据具有更强的平台独立性**。
### 1.5.表示代码
二进制代码很少能在不同机器和操作系统组合之间移植。

### 1.6.布尔代数(Boolean algebra)
- 布尔运算~对应于逻辑运算NOT
- &对应于逻辑运算AND
- |对应逻辑运算OR
- ^对应逻辑运算异或
![[Pasted image 20250917204727.png]]
### 1.7.C语言中的位级运算
位级运算的一个常见用法是实现**掩码运算**，掩码是一个**位模式**，表示从一个字中**选出的位的集合**。
	例如x&0xFF生成一个由x的最低有效字节组成的值，而其它字节被替换为0。
### 1.8.C语言中的逻辑运算
如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。
![[Pasted image 20250917205300.png]]
### 1.8.C语言中的移位运算
![[Pasted image 20250917205348.png]]
对于一个由w位组成的数据类型，移动k位，**k>=w**，在大多数机器上，移动一个w位的值时，移位指令指挥考虑位移量的低log2W位，因此实际上位移量就是通过计算**k mod w**得到的。
	比如说对一个32bit的数字，右移32,36,40位，实际上会移动0,4,8位。

---
## 2.整数表示
![[Pasted image 20250918154723.png]]
### 2.1.整数数据类型
有符号数的取值范围不是对称的--负数的范围比整数的范围大1。
### 2.2.无符号数的编码
- 每个介于0~$2^w-1$之间的数都有唯一一个w位的值编码。
原理：**无符号数编码的唯一性**
### 2.3.补码编码
- 符号位被设置为1时，表示值位负，而当设置为0时，值为非负。
- 同无符号表示一样，在可表示的取值范围内的每一个数字都有一个唯一的w位补码编码。
原理：**补码编码的唯一性**

补码的范围是不对称的：|TMin| = |TMax|+1；

> 有符号数的其他表示方法：
> 反码(One's Complement)：补码 = 反码 + 1；
> 原码(Sign-Magnitude)：最高有效位是符号位，用来确定剩下的位应该取负权还是正权，浮点数中使用原码编码。

### 2.4.有符号数与无符号数之间的转换
**强制转换**：保持位模式不变，只是改变了解释这些位的方式。
原理：补码转换为无符号数
![[Pasted image 20250918162146.png]]
当将一个有符号数映射为它相应的无符号数时，负数就被转换成了大的正数，而非负数会保持不变。

### 2.5.C语言中的有符号数与无符号数
- 在大多数系统遵循的原则是**底层的位表示保持不变**。
- 对同时包含有符号和无符号数表达式的这种处理方式：如果一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地**将有符号参数强制类型转换为无符号数**，并假设这两个数都是非负的。

### 2.6.扩展一个数字的位表示
原理：
- 无符号数的零扩展；
- 补码数的符号扩展；
- 将short转换为unsigned时，先要**改变大小**，之后再完成**有符号数到无符号**的转换。

### 2.7.截断数字
原理：
- 截断无符号数：x' = x mod $2^k$
- 截断有符号数：x' = U2T(x mod $2^k$)
有关取模：[[P1017-进制转换]]

### 2.8.关于有符号数与符号数的建议
有符号数和无符号数之间存在细微的差异，这点细微的差异容易造成难以发现的错误：避免这类错误的一种方法是**绝不使用无符号数**。
```c
unsigned length;
for(int i = 0;i <= length-1;i++) printf("error!");
```
当参数`length`等于0的时，应该不删除error！，然而并非如此，因为length是unsigned,所以`length - 1` = `Tmax`;

---
## 3.整数运算
### 3.1.无符号数加法
![[Pasted image 20250920194848.png]]
### 3.2.补码加法
![[Pasted image 20250920195138.png]]
### 3.3.补码的非
![[Pasted image 20250920195324.png]]
### 3.4.无符号乘法
![[Pasted image 20250920195357.png]]
### 3.5.补码乘法
![[Pasted image 20250920195424.png]]
### 3.6.乘以常数
左移n位。
![[Pasted image 20250920195629.png]]
### 3.7.除以常数
右移n位。
### 3.8.整数运算的思考：
- 计算机执行的“整数”运算实际上是一种模运算形式。表示数字的 有限字长限制了可能的值的取值范围，结果运算可能溢出。
---
## 4.浮点数
### 4.1.二进制小数：
![[Pasted image 20250925203943.png]]
### 4.2.IEEE浮点表示
![[Pasted image 20250925205138.png]]
![[Pasted image 20250925205147.png]]
#### 1.规格化的值：
- 在IEEE标准中，尾数被定义为`M = 1 + f`，被称为隐含的以1开头的(implied leading 1)表示。
- 阶码字段被解释为以偏移(biased)形式表示的有符号整数。也就是说阶码的值是`E = e - Bias`，而解码等于$2^{k-1} -1$ (单精度是127，双精度是1023)的偏置值。
#### 2.非规格化的值：
- 阶码域全为0时，所表示的数是非规格化形式。阶码值是`E = 1 - Bias`。而尾数的值是`M = f`，也就是小数字段的值，不包含隐含的开头的1。
- 非规格化的值提供了表示数值0的方法，有`-0.0`和`+0.0`之分。
- 可以表示那些非常接近于0.0的值，提供*逐渐溢出(gradual underflow)*，可能的数值分布均匀地接近0.0。
#### 3.特殊值：
- 当阶码全为1时出现特殊值。
- 如果小数域全为0，得到的值表示无穷：
	- 当s = 0时表示+∞。
	- 当s = 1时表示-∞。
- 当小数域不全为0时，得到的值称为NaN，即“不是一个数(Not a Number)”。
### 4.3.数字示例
![[Pasted image 20250925210429.png]]
最大非规格数$\frac{7}{512}$ 和最小化规格数$\frac{8}{512}$之间具有平滑转变。这种平滑性归功于我们对非规格化数的E的定义：通过将E定义为1 - Bias ，而不是-Bias，我们可以补偿非规格数的尾数没有隐含的开头的1。
### 4.4.舍入(Rounding)
- 因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。
- 向偶数舍入(round-to-evan)，也被称为向最接近的值舍入(round-to-nearest)，是默认的方式。
- 向偶数舍入方式采用的方法是：它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。
- 向偶数舍入在大多数现实情况下避免了例如
	- 全部向上舍入会导致得到的一组数的平均值比真实值偏高。
	- 全部向上舍入会导致得到的一组数的平均值比真实地偏低。
- 这样的统计偏差。
### 4.5.浮点运算
- 当参数中有一个是特殊值(如-0、-∞或NaN)时，IEEE标准定义了一些使之更合理的规则。例如，定义`1/-0`将产生`-∞`，而定义`1/+0`会产生+∞。
- IEEE标准指定浮点运算可以独立于任何具体的硬件或者软件实现。
- IEEE的浮点运算是：
	- 可交换的。
	- 是不可结合的：可能发生溢出，或者由于舍入而失去精度。
	- 大多数值在浮点加法下都有逆元，但无穷和NaN是例外情况。
	- 满足了单调性属性。
### 4.6.C语言中的浮点数
在支持IEEE浮点格式的机器上，C语言下。`float`对应于单精度，`double`对应于双精度浮点。
- 从int转换成 float 数字不会溢出，但是可能被舍入。
- 从float或者double转换成int 值将会向零舍人。
- 从double转换成 float 因为范围要小一些，所以值可能溢出成+∞或-∞，另 外，由于精确度较小，它还可能被舍人
## 5.小结

诸如IEEE754标准下的浮点数表示等位模式下的数字表示与转换设计的如此巧妙，以至于让 