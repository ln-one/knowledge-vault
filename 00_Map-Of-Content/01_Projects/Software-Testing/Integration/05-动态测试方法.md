---
tags:
- Knowledge/SoftwareTesting
created: 2025-11-03
author:
- ln1
status: Done
---

# 05-动态测试方法

## 概述

动态测试方法是通过运行软件来检验其功能和性能的测试方法。动态测试包括**动态黑盒测试**（不了解内部实现的功能测试）和**动态白盒测试**（基于代码结构的测试）两大类。

## 动态黑盒测试

### 基本概念
- **定义**：不深入代码细节测试的动态测试软件方法，常被称为**行为测试**
- **核心**：在不了解软件如何工作的前提下进行测试，通过输入输出来验证功能
- **测试用例**：清楚了被测试软件的输入输出之后，定义测试用例(test case)

### 测试策略分类

#### 1. 通过性测试(Test-to-Pass)
- **目的**：确认软件至少能做什么，而不会考验其能力
- **特点**：验证正常功能是否正确实现
- **应用**：基本功能验证

#### 2. 失效性测试(Test-to-Fail)
- **目的**：纯粹为了破坏软件而设计和执行的测试用例
- **别名**：错误强制测试
- **特点**：通过异常输入和边界条件来发现软件缺陷

### 等价类划分方法

#### 基本概念
- **定义**：分步骤地把海量(无限)的测试用例集缩减得很小的方法
- **别名**：等价分类(equivalence classing)
- **目标**：把可能的测试用例集缩减到可控制且仍然足以测试软件的小范围内

#### 等价类类型

**1. 有效等价类**
- 完全满足产品规则说明的输入数据
- 即有效的、有意义的输入数据所构成的集合
- 用于检验程序是否满足规则说明所规定的功能性要求

**2. 无效等价类**
- 不满足程序输入要求或者无效的输入数据构成的集合

## PDF重点：集成测试

### 集成测试概述

在每个模块完成单元测试后，需要按照设计时做出的结构图把他们连接起来，进行集成测试以检验概要设计中对模块之间接口设计的问题。集成测试又称**灰盒测试**，集成测试两种常用的辅助模块是**驱动模块**和**桩模块**。

### 集成测试的十种方法（考试重点）

1. **一次性测试** - 将所有模块一次性集成测试
2. **自顶向下测试** - 从顶层模块开始逐步向下集成
3. **自底向上测试** - 从底层模块开始逐步向上集成
4. **协作测试** - 多个模块协同工作的测试
5. **基干集成** - 基于主要功能路径的集成
6. **层次集成** - 按系统层次结构进行集成
7. **客户/服务器集成** - 客户端和服务器端的集成测试
8. **分布服务集成** - 分布式系统的集成测试
9. **高频集成** - 频繁进行的集成测试
10. **基于调用图集成** - 根据模块调用关系进行集成

### 增式测试

**增式测试**包括：
- **自顶向下测试** - 从系统顶层开始，逐步加入下层模块
- **自底向上测试** - 从系统底层开始，逐步加入上层模块
- 用于检测容错性和异常情况处理

#### 确定等价类的方法

**1. 取值范围或值的个数**
- 一个有效等价类和两个无效等价类
- 范围内、高于范围、低于范围

**2. 输入值的集合或"必须如何"的条件**
- 一个有效等价类和一个无效等价类
- 满足条件的集合、不满足输入条件的数据

**3. 布尔量**
- 一个有效等价类和一个无效等价类
- Boolean、Non-Boolean

**4. 输入数据的一组值(n个)**
- n个有效等价类和一个无效等价类
- 程序要对每一个输入值分别处理

**5. 输入数据必须遵守的规则**
- 一个有效等价类(符合规则)和若干个无效等价类(从不同角度违反规则)

### 边界值分析方法

#### 基本概念
- **定义**：程序的很多错误发生在输入或输出范围的边界上，因此针对各种边界情况设置测试用例，可以更有效地发现缺陷
- **设计方法**：
  1. 确定边界情况（输入或输出等价类的边界）
  2. 选取正好等于、刚刚大于或刚刚小于边界值作为测试数据

#### 边界值确定方法

**1. 输入条件规定了值的范围**
- 取刚达到这个范围的边界的值
- 取刚刚超越这个范围边界的值作为测试输入数据

**2. 输入条件规定了值的个数**
- 用最大个数、最小个数
- 比最小个数少一、比最大个数多一的数作为测试数据

**3. 输入数据是有序集合**
- 选取集合的第一个元素和最后一个元素作为测试用例

**4. 程序中使用了内部数据结构**
- 选择这个内部数据结构的边界上的值作为测试用例

### PDF重点：代码覆盖测试（逻辑覆盖法）

#### 逻辑覆盖法分类

**1. 语句覆盖（Statement Coverage）**
- 选择足够的测试用例，使==程序中每一条可执行语句至少被执行一次==
- 又称行覆盖（Line Coverage）、段覆盖（Segment Coverage）、基本块覆盖（Basic Block Coverage）

**2. 判定覆盖（Decision Coverage）**
- 又叫分支覆盖
- 选择足够的测试用例，使==程序中每一个分支判断的每一种可能结果都至少被执行一次==

**3. 条件覆盖（Condition Coverage）**
- 选择足够的测试用例，使==程序中每一个分支判断中的每一个条件的可能结果都至少被执行一次==

**4. 判定/条件覆盖（Decision/Condition Coverage）**
- 选择足够的测试用例，使之同时满足判定覆盖和条件覆盖

**5. 条件组合覆盖（Multiple Condition Coverage）**
- 选择足够的测试用例，使程序中每一个分支判断中的每个条件的每一种可能组合结果都至少被执行一次

**6. 路径覆盖（Path Coverage）**
- 选择足够的测试用例，使程序中所有可能的路径都至少被执行一次


在复杂程序中：**路径覆盖 ≥ 条件组合覆盖 ≥ 条件覆盖 ≥ 判定覆盖 ≥ 语句覆盖**
### PDF重点：基本路径测试法

#### 基本概念
- **定义**：在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法
- **目标**：设计出的测试用例要保证被测试程序的每个可执行语句至少被执行一次

#### 环路复杂度计算

**McCabe复杂性度量公式**：
- **V(G) = 区域数目**
- **V(G) = 边界数目 - 节点数目 + 2**
- **V(G) = 判断节点数目 + 1**

#### 基本路径测试步骤

1. **绘制程序控制流图** - 根据程序流程图，绘制出程序的控制流图
2. **计算程序环路复杂度** - 使用McCabe复杂性度量计算
3. **找出独立路径** - 通过程序的控制流图导出基本路径集
4. **设计测试用例** - 根据程序结构和程序环路复杂性设计用例输入数据和预期结果

### PDF重点：代码级测试模式

**测试组合策略**：
1. **静态再动态**：先进行代码检查和静态结构分析，再进行覆盖测试
2. **利用静态分析结果**：通过代码检查和动态测试的方式对静态分析的结果做进一步确认
3. **覆盖测试重点**：一般可使用基本路径测试法达到语句覆盖标准，对于软件的重点模块，应使用多种覆盖标准衡量测试的覆盖率
4. **不同阶段重点**：
   - 单元测试阶段：以代码检查、覆盖测试为主
   - 集成测试阶段：需要增加静态结构分析等
   - 系统测试阶段：应根据黑盒测试的结果，采用相应的白盒测试方法

### PDF重点：黑盒测试方法详解

#### 等价类划分法
- **有效等价类**：完全满足产品规则说明的输入数据
- **无效等价类**：不满足程序输入要求或者无效的输入数据构成的集合

#### 边界值分析法
- **2/5/10原则**：2秒内响应被认为是"非常有吸引力的"，5秒内响应被认为是"比较不错的"，10秒是客户能接受的等待响应的上限

#### 判定表法
- **适用条件**：条件或影响因素没有严格的排列顺序，规则具有很强的独立性
- **组成部分**：条件桩、动作桩、条件项和动作项

#### 因果图法
- **目的**：针对更为复杂的"多种输入条件、产生多种结果"设计组合测试用例
- **基本符号**：有因必有果关系、非关系、或关系、与关系
- **约束关系**：互斥、包含、唯一、要求、屏蔽

#### Pairwise方法
- **背景**：大部分缺陷是在两个变量取值冲突的测试时被发现的
- **定义**：确保某个变量取值和另一个变量取值成对出现都会被覆盖
- **效果**：可大幅度降低组合的数量

#### 正交实验法
- **依据**：依据Galois理论，从大量的（实验）数据（测试例）中挑选适量的、有代表性的点（条件组合）
- **步骤**：确定影响功能的因子与状态 → 选择一个合适的正交表 → 利用正交表构造测试数据集

#### 场景法
- **定义**：通过运用场景来对系统的功能点或业务流程的描述，从而提高测试效果的一种方法
- **组成**：基本流和备选流
- **步骤**：
  1. 根据需求分析描绘出程序的基本流及各备选流
  2. 根据基本流和各备选流生成不同的场景
  3. 针对生成的各场景，设计相应的测试用例
  4. 重新审核设计的测试用例，去掉多余的测试用例

#### 基本概念
- **原理**：程序的很多错误发生在输入或输出范围的边界上
- **方法**：针对各种边界情况设置测试用例，选取正好等于、刚刚大于或刚刚小于边界值作为测试数据

#### 边界值确定方法

**1. 值的范围**
- 刚达到这个范围的边界的值
- 刚刚超越这个范围边界的值

**2. 值的个数**
- 最大个数、最小个数
- 比最小个数少一、比最大个数多一

**3. 特殊边界值**
- **字符**：起始-1个字符/结束+1个字符
- **数值范围**：开始位-1/结束位+1
- **空间**：比零空间小一点/比满空间大一点

#### 常见边界值

**1. 数值边界**
- Bit: 0 or 1
- Nibble: 0-15
- Byte: 0-255
- Word: 0-65535 or 0-4294967295
- Kilo: 1024
- Mega: 1048576
- Giga: 1073741824
- Tera: 1099511627776

**2. ASCII字符边界**
- Null: 0
- Space: 32
- 数字: 48-57
- 大写字母: 65-90
- 小写字母: 97-122

**3. 特殊值**
- 缺省值、空格、(none)、0、Null等
- First/last, First-1/Last+1
- Min/Max, Min-1/max+1
- Empty/Full, Less than empty/more than full

### 数据测试技术

#### 1. 边界条件(Boundary Condition)
- **定义**：软件运行在计划操作界限的边界的情况
- **原理**：如果软件能在其边界运行，那么在正常情况下应该不会有什么问题

#### 2. 次边界条件
- **定义**：位于软件内部的边界，称为次边界条件或内部边界条件
- **类型**：
  - **2的幂**：计算机内部数据表示的边界
  - **ASCII表**：以合法输入的范围作为边界条件
  - **默认、空白、空值、零值和无**：特殊输入情况
  - **非法、错误、不正确和垃圾数据**：异常输入测试

### 状态测试

#### 基本概念
- **软件状态**(software state)：软件在运行过程中的不同状态
- **目的**：测试软件的逻辑流程和状态转换

#### 测试方法

**1. 建立状态转换图**
- 软件可能进入的每一种独立状态
- 从一种状态转入另一种状态所需的输入和条件
- 进入或者退出某种状态时的设置条件及输出结果

**2. 减少要测试的状态及转换的数量**
- 每种状态至少访问一次
- 测试看起来是最常见和最普遍的状态转换
- 测试状态之间最不常用的分支
- 测试所有错误状态及其返回值
- 测试随机状态转化

**3. 失败状态测试**
- **竞争条件和时序错误**：多任务操作系统中的并发问题
- **重复、压迫和重负测试**：
  - **重复测试**(repetition testing)：不断执行同样的操作，检查内存泄露
  - **压力测试**(stress testing)：在不够理想的条件下运行
  - **重负测试**(load testing)：提供条件供其发挥，时间也是一种重负测试

### 其他黑盒测试技术

#### 1. 像笨拙的用户那样做
- **无经验用户**(inexperienced user)：不遵循任何规则，也不做任何假定
- **目的**：发现用户体验问题

#### 2. 在已经找到软件缺陷的地方再找
- **原理**：找到的缺陷越多，就说明那里的软件缺陷越多
- **注意**：许多程序员倾向于只修复报告出来的软件缺陷，不多不少

#### 3. 像Cracker一样考虑问题
- **方法**：寻找有价值的东西，尝试重点攻破
- **目的**：发现安全漏洞

#### 4. 凭借经验、直觉和预感
- **错误猜测法**：测试者根据经验、知识和直觉来发现软件错误
- **常见错误来源**：
  - 单元测试中发现的模块错误
  - 产品的以前版本曾经发现的错误
  - 输入数据为0或字符为空
  - 没有输入任何内容，单单按了Enter键

## 动态白盒测试

### 基本概念
- **定义**：利用查看代码功能和实现方式得到的信息来确定那些需要测试、那些不需要测试、如何开展测试
- **别名**：结构化测试(structural testing)
- **目标**：寻找软件缺陷，而不是修复缺陷

### 分段测试策略

#### 🔥 PDF重点：测试层次分类（考试必考）

**软件测试分为四个层次**：

1. **模块测试（单元测试）**
   - 目的：检验每个模块是否能单独工作
   - 发现：模块的编码问题和算法问题
   > 🧩 *形象比喻*：就像检查每个零件是否合格

2. **集成测试**
   - 目的：将多个模块连接起来检验概要设计中对模块之间接口设计的问题
   - 别名：灰盒测试
   > 🔗 *连接测试*：检查零件组装后是否配合良好

3. **确认测试**
   - 目的：以需求规格说明书中的规定作为检验尺度，发现需求分析的问题
   > ✅ *需求验证*：确认产品是否符合客户要求

4. **系统测试**
   - 目的：将开发的软硬件和其他因素综合起来进行全面的检验
   > 🌐 *整体测试*：在真实环境中测试完整系统

#### PDF重点：集成测试的十种方法

1. **一次性测试** - 所有模块同时集成，风险高但速度快
2. **自顶向下测试** - 从主模块开始逐步向下，需要编写桩模块
3. **自底向上测试** - 从底层模块开始向上，需要编写驱动模块
4. **协作测试** - 相关模块协同测试
5. **基干集成** - 先集成核心功能
6. **层次集成** - 按层次逐步集成
7. **客户/服务器集成** - C/S架构的集成方式
8. **分布服务集成** - 分布式系统集成
9. **高频集成** - 频繁的小规模集成
10. **基于调用图集成** - 根据模块调用关系集成

#### PDF重点：增式测试

**增式测试**：自顶向下测试和自底向上测试

**集成测试又称灰盒测试**，集成测试两种常用的辅助模块是驱动模块和桩模块。

#### PDF重点：集成测试的必要性

1. **验证模块交互与接口兼容性** - 单个模块通过单元测试后，仍可能在集成时出现接口数据丢失、功能冲突或全局数据异常等问题
2. **提升系统稳定性和可靠性** - 集成测试能识别模块间潜在的误差累积效应
3. **支持持续集成与快速迭代** - 现代开发中，集成测试与持续集成（CI）结合
4. **满足复杂系统的特殊需求** - 高安全性系统、大规模系统、微服务架构
5. **降低后期修复成本** - 集成阶段发现的缺陷修复成本仅为系统测试阶段的1/10

#### 集成测试的辅助模块

**1. 驱动模块（Driver）**
- 作用：调用被测试模块的主程序
- 功能：接收测试数据，传送给被测模块，输出结果
> 🚗 *司机角色*：驱动其他模块运行

**2. 桩模块（Stub）**
- 作用：代替被测试模块调用的子模块
- 功能：模拟被调用模块的基本功能
> 🎭 *替身演员*：临时替代真正的模块

#### 测试层次
- **单元测试**(unit testing)或**模块测试**(module testing)：底层测试
- **集成测试**(integration testing)：模块组合测试
- **系统测试**(system testing)：整个系统测试

#### 集成方式

**1. 自底向上**(bottom-up)
- 编写称为测试驱动的模块调用正在测试的模块
- 从最底层模块开始集成

**2. 自顶向下**(top-down)
- 小规模的大爆炸测试
- 先完成高层软件，编写一小段称为**桩**(stub)的代码充当接口模块

### 数据覆盖测试

#### 1. 数据流(Data Flow)
- **定义**：在软件中完全跟踪一批数据
- **优势**：通过动态白盒测试，还可以在程序运行期间检查变量的中间值

#### 2. 次边界
- 进行白盒测试，仔细检查代码，找到次边界条件

#### 3. 公式和等式
- 验证计算逻辑的正确性

#### 4. 错误强制(Error Forcing)
- **注意**：小心不要设置现实世界中不可能出现的情况
- **方法**：迫使软件中的所有错误提示信息显示出来

### PDF重点：代码覆盖测试（白盒测试技术）

#### 逻辑覆盖法
以程序内在的逻辑结构为基础，根据程序的流程图设计测试用例。根据覆盖的目标不同，分为：

**1. 语句覆盖**
- 选择足够的测试用例，使程序中每一条可执行语句至少被执行一次
- 又称行覆盖、段覆盖、基本块覆盖

**2. 判定覆盖（分支覆盖）**
- 选择足够的测试用例，使程序中每一个分支判断的每一种可能结果都至少被执行一次

**3. 条件覆盖**
- 选择足够的测试用例，使程序中每一个分支判断中的每一个条件的可能结果都至少被执行一次

**4. 判定/条件覆盖**
- 选择足够的测试用例，使之同时满足判定覆盖和条件覆盖

**5. 条件组合覆盖**
- 选择足够的测试用例，使程序中每一个分支判断中的每个条件的每一种可能组合结果都至少被执行一次

**6. 路径覆盖**
- 选择足够的测试用例，使程序中所有可能的路径都至少被执行一次

#### 覆盖方法的强度关系
- 路径覆盖 > 条件组合覆盖 > 判定/条件覆盖 > 条件覆盖 > 判定覆盖 > 语句覆盖
- 满足条件组合覆盖标准的测试数据，也一定满足判定覆盖、条件覆盖和判定/条件覆盖标准
- 但满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到

#### PDF重点：基本路径测试法

**定义**：在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。

**基本路径测试主要包含四个方面**：
1. **绘制出程序的控制流程图** - 根据程序流程图，绘制出程序的控制流图
2. **计算程序环路复杂度** - 环路复杂度是一种为程序逻辑复杂性提供定量测度的软件度量
3. **找出独立路径** - 通过程序的控制流图导出基本路径集，列出程序的独立路径
4. **设计测试用例** - 根据程序结构和程序环路复杂性设计用例输入数据和预期结果

**环路复杂度计算公式**：
- **V(G) = 区域数目**
- **V(G) = 判断节点数 + 1**
- **V(G) = 边界个数 - 节点个数 + 2**

**独立路径**：指包括一组以前没有处理过的语句或条件的一条路径。控制流图中一条独立路径是至少包含有一条在其他独立路径中从未有过的边的路径。

#### PDF重点：代码级测试模式

1. **先静态再动态的组合方式** - 先进行代码检查和静态结构分析，再进行覆盖测试
2. **利用静态分析的结果作为引导** - 通过代码检查和动态测试的方式对静态分析的结果做进一步确认
3. **覆盖测试是白盒测试的重点** - 一般可使用基本路径测试法达到语句覆盖标准
4. **不同阶段的重点** - 单元测试阶段以代码检查、覆盖测试为主；集成测试阶段需要增加静态结构分析等；系统测试阶段应根据黑盒测试的结果，采用相应的白盒测试方法

### 单元测试

#### 测试对象
- 最小单位（函数、类方法、功能模块、组件）
- 能够实现一个特定功能
- 具有一定独立性或者通过明确接口定义与其他单元联系

#### 测试目的
- 检验软件单元能否正确地实现其功能
- 满足性能和接口要求
- 验证代码和详细设计说明一致性

#### 单元测试的任务

**1. 单元独立执行路径的测试**
- 检验单元中每条语句能够正确执行
- 检查问题：误解或用错了算符优先级、混合类型运算、变量初始化错误、错误计算或精度不够、表达式符号错误等

**2. 单元局部数据结构的测试**
- 检查临时存储的数据在程序执行过程中是否正确、完整
- 检查问题：不合适或不相容的类型说明、变量无初值、变量初始化或默认值有错、不正确的变量名、出现上溢、下溢和地址异常

**3. 单元接口测试**
- 检验数据能正确输入、输出的前提下的接口功能
- 检查问题：输入的实际参数与形式参数的个数、类型等是否匹配、调用其他单元时所给实际参数与被调单元的形式参数个数、属性和量纲是否匹配等

**4. 单元边界条件的测试**
- 采用边界值分析技术，针对边界值及其最靠近的两个值设计测试用例

**5. 单元容错性测试**
- 防御式编程，预见各种可能的出错条件，并对出错进行正确处理
- 检查问题：输出的出错信息难以理解、记录的错误与实际遇到的错误不相符、在程序自定义的出错处理代码运行之前系统已介入、异常处理不当、错误陈述中未能提供足够的定位出错信息

**6. 内存分析**
- 内存泄露会导致系统运行的崩溃
- 通过检查内存使用可以了解程序内存分配的真实情况
- 发现对内存的不正常使用，在问题出现前发现征兆

#### 单元测试方法
- **主要方法**：白盒测试+辅助黑盒测试
- **白盒测试**：将被测程序看作一个打开的盒子，对代码进行全面的逻辑分析后准确定位，进行有效的测试
- **测试技术**：逻辑驱动法和基本路径测试法

#### 驱动程序与桩程序
- **驱动单元**(Driver)：所测函数的主程序，它接收测试数据，并把数据传送给所测试单元，最后再输出实测结果
- **桩单元**(Stub)：用来代替所测单元调用的子单元

## 高级测试方法

### 组合测试方法

#### 1. 判定表方法
- **适用**：多个因素构成的输入，需要多因素组合分析
- **组成**：条件桩、动作桩、条件项和动作项
- **规则**：任何一个条件组合的特定取值及其相应的动作

#### 2. 因果图法
- **目的**：针对更为复杂的"多种输入条件、产生多种结果"设计组合测试用例
- **方法**：
  - 分析软件Spec描述的哪些是原因（输入条件）、哪些是结果（输出）
  - 找出原因与结果、原因与原因之间的对应关系，画出因果图
  - 在因果图上标上哪些不可能发生的因果关系，表明约束或限制条件
  - 根据因果图，创建判定表
  - 把判定表的每一列转化为测试用例

#### 3. Pairwise方法（两两组合）
- **背景**：大部分缺陷是在两个变量取值冲突的测试时被发现的
- **定义**：确保某个变量取值和另一个变量取值成对出现都会被覆盖
- **效果**：可大幅度降低组合的数量

#### 4. 正交实验法
- **依据**：Galois理论，从大量的实验数据中挑选适量的、有代表性的点
- **方法**：
  - 确定影响功能的因子与状态
  - 选择一个合适的正交表
  - 利用正交表构造测试数据集

### 场景法
- **基本流**：正常的业务流程
- **备选流**：异常或分支流程
- **步骤**：
  1. 根据需求分析描绘出程序的基本流及各备选流
  2. 根据基本流和各备选流生成不同的场景
  3. 针对生成的各场景，设计相应的测试用例
  4. 重新审核设计的测试用例，去掉多余的测试用例

## 自动化测试

### 基本概念
- **定义**：把以人为驱动的测试行为转化为机器执行的一种过程
- **目的**：节省人力、时间或硬件资源，提高测试效率

### 自动化测试原理

#### 1. 代码分析（白盒测试方法）
- 分析被测对象就是对其代码进行语法扫描
- 找出不符合编码规则的地方
- 根据质量模型评价代码质量，生成系统的调用关系图

#### 2. 录制和回放（黑盒测试方法）
- **录制**：将用户的每一步操作都记录下来，并转换成脚本语言
- **回放**：将脚本语言的描述转换为屏幕上的操作，然后将被测系统的输出与预期结果进行比较

#### 3. 脚本技术
- 脚本是一种特殊的计算机程序，包含了数据和指令
- 脚本产生方法：通过录制产生然后再做修改；用脚本语言编写程序

#### 4. 对象识别技术
- 按照屏幕的实际像素坐标来定位
- 通过寻找UI上的对象来确定操作的目标
- 通过图像识别算法对图片进行图像匹配和文字识别

#### 5. 虚拟用户技术
- 通过模拟真实用户的数量和操作行为，对被测程序施加负载
- 以测量系统的性能指标，包括响应时间和吞吐量等

### 自动化测试脚本类型

#### 1. 线性脚本
- 录制手工测试获得的脚本
- 录制动作有击键、移动、输入数据等
- 所有录制的测试用例都可以完整地回放

#### 2. 结构化脚本
- 具有各种逻辑结构，包括选择、分支、循环迭代
- 还有函数调用功能

#### 3. 共享脚本
- 可以被多个测试用例使用的脚本
- 允许其他脚本调用
- 可以在不同主机、不同系统之间共享

#### 4. 数据驱动脚本
- 将测试的输入存储在独立的数据文件中，而不是存储在脚本中
- 可以针对不同数据输入实现多个测试用例

#### 5. 关键字驱动脚本
- 数据驱动脚本的逻辑扩展
- 将数据文件变成测试用例的描述
- 采用一些关键字指定要执行的任务

## 总结

动态测试方法通过运行软件来验证其功能和性能，包括：

1. **动态黑盒测试**：
   - 等价类划分和边界值分析是核心技术
   - 状态测试和数据测试覆盖不同的测试场景
   - 组合测试方法处理复杂的多因素情况

2. **动态白盒测试**：
   - 代码覆盖测试确保充分的测试覆盖
   - 单元测试是白盒测试的基础
   - 基本路径测试法提供系统的测试方法

3. **自动化测试**：
   - 提高测试效率和可重复性
   - 支持回归测试和大规模测试
   - 多种脚本类型适应不同的测试需求

动态测试方法的选择应该根据具体的测试目标、软件特性和项目约束来确定，通常需要多种方法的组合使用才能达到最佳的测试效果。

---

**相关链接**：
- [[01-软件测试背景与概念]]
- [[02-软件开发过程]]
- [[03-软件测试实质]]
- [[04-静态测试方法]]

**标签** #软件测试  #动态测试 #黑盒测试 #白盒测试 #自动化测试