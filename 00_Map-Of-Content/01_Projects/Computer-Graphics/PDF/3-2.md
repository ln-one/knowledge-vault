# 第三章 基本图形生成算法

实区域填充与反走样


内容提要

 3. 1 直线生成算法

 3. 2 圆弧生成算法

 3. 3 线宽和线型的处理

 3. 4 实区域填充算法

 3. 5 图形反走样技术


直线的扫描转换

#### 假设坐标原点位于左下角点

#### 则像素由其左下角坐标表示


实区域填充算法（ **1 / 9** ）

#### – 确定待填充的像素

#### – 即检查光栅屏幕上的每一像素

#### 是否位于多边形区域内

 解决的主要问题是什么？

```
y
```
```
0 1 2 3 4 5 6 7 8 91011 x
```
```
1
2
3
```
```
4
5
67
```
(^8) P 6 P^4
P 1
P 5
P 2
P 3


实区域填充算法（ **2 / 9** ）

 图案填充，哪个像素填什么颜色

 曲线围成的区域，可用多边形逼近


实区域填充算法（ **3 / 9** ）

```
如何判断一个点是否位于多边形
区域内？
```
点在多边形内的包含性检验

- 检验夹角之和
- 射线法检验交点数


实区域填充算法（ **4 / 9** ）

#### 若夹角和为 0 ，

#### 则点 P 在多边形外

#### 若夹角和为 360 °，

#### 则点 P 在多边形内

```
A
```
B

```
C
```
```
D
```
```
E
```
```
P
```
```
A
```
```
B
```
```
C
```
```
D
```
```
E
P
```
检验夹角之和


实区域填充算法（ **5 / 9** ）

夹角计算

- 大小：利用余弦定理
- 方向：令

```
( A P )( B P ) ( B P )( A P )
B P B P
```
```
A P A P x x z z x x z z
x x z z
```
```
x x z z
T      
 
```
```
 

```
```
当 T < 0 时，
AP 斜率 > BP 斜率，
为顺时针角
```
_z_

```
x
```
#### A

#### B

#### P

```
z
```
```
x
```
#### B

#### A

#### P


实区域填充算法（ **6 / 9** ）

```
A
```
```
B
```
```
C
```
```
D
```
```
E
```
#### 交点数=偶数(包括 0 )

#### 点在多边形之外

#### 交点数=奇数

#### 点在多边形之内

射线法检验交点数

```
P
```
```
A
```
```
B
```
```
C
```
```
D
```
```
E
```
P


逐点测试的问题？

- 效率低不实用
一个简单的解决方法
- 包围盒法

#### 凸多边形 凹多边形

实区域填充算法（ **7 / 9** ）

#### 效率仍然很低


实区域填充算法（ **8 / 9** ）

换一种思路：

考虑图形的扫描方式特点

- 能否利用扫描线的连贯性？

考虑图形的特点

- 能否利用图形的空间连贯性？


实区域填充算法（ **9 / 9** ）

分类：

扫描线填充算法

- 按扫描线顺序测试点的连贯性

种子填充算法

- 从内部一个种子点出发测试点的连

贯性


(^01234567)
1
2
3
4
5
6
7
y
x
8
8 9 10
扫描线 5
P 4
P 1 P 2
P 3
P 5
扫描线 2
I 1 I 2 I^3 I^4
扫描线 3
扫描线填充算法（ **1 / 27** ）
扫描线的连贯性
扫描线上点
的连贯性
上下两条扫描线
上点的连贯性


## y

 交点配对： **(I 1 , I 2 ), (I 3 , I 4 )**

      -
      -
      -
      -
      -
      -
      -
      -
   - x
                     -
                           - 扫描线
                  - P
         - P 1 P
                        - P
               - P
                           - 扫描线
            - I 1 I 2 I^3 I
-  求交： I 4 , I 3 , I 2 , I 扫描线填充算法（ 2 / 27 ）
-  排序： I 1 , I 2 , I 3 , I


扫描线填充算法（ **3 / 27** ）

```
顶点交点的计数问题
计数 1 次吗？
```
```
应该计数 1 次
```
#### 计数 1 次吗？

```
5
4
3
2
1
0 P^5 P^2
```
```
P 3
```
```
P 4
```
```
I 1
```
```
I 2 I 3
```
```
I 4
```
```
P 1
```
```
扫描线 5
扫描线 4
```
```
扫描线 1
```
```
I 5
```
```
I 6
```
思考第一个问题：

 交点配对时可能出现的问题？

```
 会不会出现奇数个交点？
```

扫描线填充算法（ **4 / 27** ）

顶点交点的计数问题

- 局部最高点和局部最低点的交点计数问题**?**
- 如何判断局部最高点和局部最低点？

#### 计数 1 次吗？

#### 应该计数 1 次

#### 计数 1 次吗？

```
5
4
3
2
1
0 P^5 P^2
```
```
P 3
```
```
P 4
```
```
I 1
```
```
I 2 I 3
```
```
I 4
```
```
P 1
```
```
扫描线 5
扫描线 4
```
```
扫描线 1
```
```
I 5
```
```
I 6
```

扫描线填充算法（ **5 / 27** ）

顶点交点的计数问题

- 局部最高点和局部最低点计偶数次交点

#### 计偶数次

#### 应该计数 1 次

#### 计偶数次

```
5
4
3
2
1
0 P^5 P^2
```
```
P 3
```
```
P 4
```
```
I 1
```
```
I 2 I 3
```
```
I 4
```
```
P 1
```
```
扫描线 5
扫描线 4
```
```
扫描线 1
```
```
I 5
```
```
I 6
```

扫描线填充算法（ **6 / 27** ）

顶点交点的计数问题

- 检查交于该顶点的两条边的另外两个端
    点的y坐标值大于该顶点y坐标值的个数

#### 计数 0 次

#### 计数 1 次

#### 计数 0 次

```
5
4
3
2
1
0 P^5 P^2
```
```
P 3
```
```
P 4
```
```
I 1
```
```
I 2 I 3
```
```
I 4
```
```
P 1
```
```
扫描线 5
扫描线 4
```
```
扫描线 1
```
```
I 5
```
```
I 6
```

扫描线填充算法（ **7 / 27** ）

思考第二个问题

区间填色时可能出现的问题？

#### – 会不会填充到区域之外呢？


扫描线填充算法（ **8 / 27** ）

填充扩大化问题

- 求出交点的坐标为： **_xl_** **= 1 ,** **_xr_** **= 5**
- 有 **5** 个点在配对区间内
- 即满足： **_xl_** **≤** **_x_** **≤** **_xr_**

(^01234567)
1
23
45
6
y 7
0 1 2 3 4 5 6 7 x
1
23
45
6
y 7

### x

P (^1) P 2
P 4 P 3

#### 像素由其左下角坐标表示


扫描线填充算法（ **9 / 27** ）

如何解决填充扩大化问题？

- 取中心扫描线 **_y_** **+ 0. 5**
- 检查交点右方像素的中心是否落在区间内
**_xl_** **≤** **_x_** **+ 0. 5 ≤** **_xr_**

(^01234567)
1
23
4
5
6
y 7
0 1 2 3 4 5 6 7 x
1
23
4
5
6
y 7
x
P (^1) P 2
P 4 P 3


扫描线填充算法（ **10 / 27** ）

填充过程

- 求出交点的坐标为： **_xl_** **= 1 ,** **_xr_** **= 5**
- 有 **4** 个点在配对区间内
- 即满足： **_xl_** **≤** **_x_** **+ 0. 5 ≤** **_xr_**

(^01234567)
1
23
4
5
6
y 7
0 1 2 3 4 5 6 7 x
1
23
4
5
6
y 7
x
P (^1) P 2
P 4 P 3


扫描线填充算法（ **11 / 27** ）

步骤：

- 求交和交点排序
- 把多边形所有边放在一个表中
- 按顺序取出
- 分别计算与当前扫描线求交点

```
思考第三个问题：效率问题
 影响算法效率的因素是什么？
```

扫描线填充算法（ **12 / 27** ）

```
 并非所有的边都与当前扫描线有交点？
 如何提高效率？
 如何减少和简化求交计算？
 对每条扫描线，建立一个活性边的表
 何谓活性边？
 仅与当前扫描线有交点的边
 活性边表：把所有与当前扫描线有交点
的边放到一个表中存储
```

扫描线填充算法（ **13 / 27** ）

 存储活性边的哪些信息呢？

 目的是要保证存储的这些信息，对计算

活性边与扫描线的交点有用

 最有用的信息是当前扫描线与活性边的

交点 **_x_**

 为了下一条扫描线与活性边求交方便，

我们还需要知道什么信息呢？

```
x
```

扫描线填充算法（ **14 / 27** ）

 为方便下一条扫描线与活性边求交

- 从当前扫描线到下一条扫描线的 **_x_** 增量△ **_x_**

(^01234567)
1
2
3
4
5
6
7
y
x
8
8 9 10
扫描线 5
P 4
P 1 P 2
P 3
P 5
扫描线 2
I 1 I 2 I^3 I^4 △ _y_ =^1 扫描线 4
△ _x_
**_x’_** **=** **_x_** **+** △ **_x
y’_** **=** **_y_** **+** △ **_y_**
**(** **_x_** **,** **_y_** **)
(** **_x’_** **,** **_y’_** **)**

- △ **_x_** **= 1 /** **_k_**

```
x △^ x
```

(^01234567)
1
2
3
4
5
6
7
y
x
8
8 9 10
扫描线 5
P 4
P 1 P 2
P 3
P 5
扫描线 2
I 1 I 2 I^3 I^4
**(** **_x_** **,** **_y_** **)** 扫描线 6
扫描线 7
扫描线填充算法（ **15 / 27** ）
 下一条扫描线是否与活性边总有交点呢？
记录活性边所交的最高扫描线号 **_ymax_**
当 **_y_** **>** **_ymax_** 时，将活性边从活性边表中删除

#### ？

```
x △^ x ymax
```

扫描线填充算法（ **16 / 27** ）

 活性边表的建立

 结点信息

- **_x_** ：当前扫描线与边的交点
- △ **_x_** ：从当前扫描线到下一条扫描线之间的 **_x_** 增量
- **_ymax_** ：边所交的最高扫描线号

```
x △^ x ymax x △^ x ymax
```

扫描线填充算法（ **17 / 27** ）

活性边表的更新

```
1. 结点信息的更新
2. 旧边的删除
3. 新边的插入 x’ = x + △ x
```
```
x △^ x ymax
```
```
x’ △^ x ymax
```
```
4. 5 - 3 2. 5. 5 3 3 ∧
```
```
P 1 P 2 P 2 P 3
y= 1. 5
```
```
2 0 7. 8. 5 3 3 ∧
```
P 6 P (^1) P 2 P 3
_y_ **_= 2. 5_**


扫描线填充算法（ **18 / 27** ）

 如何解决新边插入的问题？

```
 对每条扫描线建立一个新边表
```
 新边表需要什么结点信息？

```
 以方便建立活性边表的结点信息为目的
 最好是可以将新边表中的信息直接插入到活
性边表中
```

扫描线填充算法（ **19 / 27** ）

 结点信息

**_x 0_** ：扫描线与边的初始交点

若采用中心扫描线，则需将活性边的较低端点的 **_x_** 坐标值加上 **0. 5** △ **_x_** 作为 **_x_** **0**

```
△ x ：从当前扫描线到下一条扫描线之间的 x 增量
ymax ：边所交的最高扫描线号
```
 由于是新边，扫描线与边的交点应

```
为扫描线与边的初始交点
x 0 △^ x ymax
```
```
△ x = 1 / k
```

```
y
```
```
x
0 1 2 3 4 5 6 7 8 91011
```
```
1
```
2
3
4

```
5
```
```
67
```
(^8) P 6 P^4
P 1
P 5
P 2
P 3

#### 新

#### 边

#### 表

```
8. 5
7. 5
6. 5
5. 5
4. 5
3. 5
2. 5
1. 5
0. 5
```
```
∧
∧
∧
∧
```
```
∧
```
```
6 2 8. 4. 25 -^1.^57 ∧
11 0 8 ∧
2 0 7 ∧
3. 5 - 3 2. 6. 5 3 3 ∧
```
```
P 4 P 5 P^5 P^6
```
```
P 3 P 4
P 6 P 1
```
```
P 1 P 2 P 2 P 3
```
#### 活

#### 性

#### 边

#### 表

```
3. 5 -^32. 6. 5 3 3 ∧
```
```
P 1 P 2 P 2 P 3
y= 1. 5
2 0 7. 9. 5 3 3 ∧
```
P 6 P (^1) P 2 P 3
_y_ **_= 2. 5_**
2 0 7. 11 0 8 ∧
P 6 P 1 P 3 P 4
**_y= 3. 5 / 4. 5_**
6 2 8.
P 4 P 5
11 0 8 ∧
P 3 P 4
4. 25 -^1.^57
P 5 P 6
2 0 7.
P 6 P 1
**_y= 5. 5_**
8 2 8.
P 4 P 5
11 0 8 ∧
P 3 P 4
2. 75 -^1.^57
P 5 P 6
2 0 7.
P 6 P 1
**_y= 6. 5_**
10 2 8.
P 4 P 5
11 0 8 ∧
P 3 P 4
**_y= 7. 5_**


扫描线填充算法（ **21 / 27** ）

该算法称为：有序边表算法

优点：

- 对每个像素只访问一次
- 与设备无关

 缺点：

- 数据结构复杂，表的维护、排序开销大
- 只适合软件实现


扫描线填充算法（ **22 / 27** ）

 边填充算法（ **Edge Fill Algorithm** ）

 优点：

- 无需复杂的链表结构

 涉及到屏幕像素的异或写操作 （取补）

 异或写操作有什么特点？

- 第一次异或写操作，像素被置成前景色
- 第二次异或写操作，像素恢复为背景色


动画或者橡皮筋技术 **(** 可视化编辑 **)** 的实现

- 利用颜色的异或操作。绘制图形时，对原有图
    形并不是擦除，而是再绘制一个同样的图形并
    与原图形进行异或操作，此时原图形会从屏幕
    上消失

扫描线填充算法（ **23 / 27** ）


```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
(a) (b) (c)
```
```
(d) (e)
```
 边填充算法的基本思想

- 对每一条与多边形相交的中心扫描线
- 将像素中心位于交点右方的全部像素取补
    （异或写）

扫描线填充算法（ **24 / 27** ）


边填充算法的优点：

- 适合有帧缓存的显示器
- 可按任意顺序处理多边形的边
- 算法简单，仅访问与该边有交点的扫描线上
    右方的像素

缺点：

- 对复杂图形，每一像素可能被多次访问，输
    入/输出量大
- 图形输出不能与扫描同步进行，只有全部画
    完才能打印

扫描线填充算法（ **25 / 27** ）


 边填充算法的改进 **——**

栅栏填充算法（Fence Fill Algorithm）

- 引入栅栏线

```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
(a) (b) (c)
```
```
(d) (e)
```
```
P 4
```
```
栅栏线
```
扫描线填充算法（ **26 / 27** ）


```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
```
```
P 5
```
```
P 1 P 2
```
```
P 3
P 4
(a) (b) (c)
```
```
(d) (e)
```
```
P 4
```
```
栅栏线
```
 栅栏填充算法的基本思想

- 将像素中心位于交点和栅栏线之间的全
    部像素取补

扫描线填充算法（ **27 / 27** ）


种子填充算法（ **1 / 10** ）

种子填充算法（ **Seed Fill Algorithm** ）

另外一种思路 **:**

假设多边形区域内至少有一个像素已知

由该像素出发找出区域内部的所有像素


种子填充算法（ **2 / 10** ）

假定区域采用边界定义法

区域连通方式：

**4** 连通区域 **8** 连通区域


种子填充算法（ **3 / 10** ）

**4** 连通与 **8** 连通区域的区别

- 连通性
- 对边界的要求（三角形是否作为边界）


种子填充算法（ **4 / 10** ）

#### 4 连通区域边界填

#### 充算法的填充结果

#### 8 连通区域边界填

#### 充算法的填充结果

区域连通方式对填充结果的影响


种子填充算法（ **5 / 10** ）

**4** 连通简单种子填充算法步骤：

种子像素入栈

当栈非空时，重复以下步骤：

- 栈顶像素出栈
- 将出栈像素置成填充色
- 按左、上、右、下顺序检查与出栈像素相邻的
    四像素，若其中某像素不在边界上且未被置成
    填充色，则将其入栈


// 4 - connected boundary-fill（边界填充）
void BoundaryFill 4 (int x,int y,int fill,int boundary)
{
int current;
current = getpixel(x, y);
if ((current != boundary) && (current != fill))
{
putpixel(x, y, fill);
BoundaryFill 4 (x+ 1 , y, fill, boundary);
BoundaryFill 4 (x- 1 , y, fill, boundary);
BoundaryFill 4 (x, y+ 1 , fill, boundary);
BoundaryFill 4 (x, y- 1 , fill, boundary);
}
}

```
// 4 - connected flood-fill (泛填充: 油漆桶填充新颜色)
void FloodFill 4 (int x,int y,int fill,int oldColor)
{
int current;
current = getpixel(x, y);
if (current == oldColor)
{
putpixel(x, y, fill);
FloodFill 4 (x+ 1 , y, fill, oldColor);
FloodFill 4 (x- 1 , y, fill, oldColor);
FloodFill 4 (x, y+ 1 , fill, oldColor);
FloodFill 4 (x, y- 1 , fill, oldColor);
}
}
```
种子填充算法的递归实现

种子填充算法（ **6 / 10** ）


(^67)
**5 4 S 9
3 2 8**
S
2
4
7
9
3
8
4
7
9
4
8
4
7
9
5 6 8 4 7 9
6
8
4
7
9
7
8
4
7
9
8
4
7
9
9
4
7
9
(^67)
**5 4 S 9
3 2 8
S**
7
(^99)

#### 简单种子填充算法

#### 的缺点？

种子填充算法（ **7 / 10** ）

```
4
7
9
```

扫描线种子填充算法

基本思想：

- 利用扫描线的连贯性，每次填充一行
    像素
- 减少压入堆栈的像素数目

种子填充算法（ **8 / 10** ）


扫描线种子填充算法步骤

种子像素入栈

当栈非空时，重复以下步骤：

- 栈顶像素出栈
- 沿扫描线对出栈像素的左右像素进行填充，直到遇
    到边界像素为止
- 将上述区间内最左、最右像素记为 **_xl_** 和 **_xr_**
- 在区间 **[** **_xl_** **,** **_xr_** **]** 中检查与当前扫描线相邻的上下两条
    扫描线是否全为边界像素、或已填充的像素，若为
    非边界、未填充的像素，则把每一区间的最右像素
    取为种子像素入栈

种子填充算法（ **9 / 10** ）


```
S
```
```
1
```
```
2
3
3
3
```
```
3
```
```
4 5
4 5
```
```
3
```
```
3
```
如何填充这个有孔的多边形？

种子填充算法（ **10 / 10** ）


内容提要

 3. 1 直线生成算法

 3. 2 圆弧生成算法

 3. 3 线宽和线型的处理

 3. 4 实区域填充算法

 3. 5 图形反走样技术


图形走样

####  图形的锯齿状：图形信号连续，而光栅显示系

#### 统中为离散表示

####  用离散量(像素)表示连续的量(图形)而引起的失

```
真，叫混淆或走样(aliasing)
```
 光栅图形走样：

- 阶梯状边界
- 图形细节失真
- 狭小图形遗失：动画序列中时隐时现，产生闪烁


走样现象（ 1 / 3 ）

不光滑（阶梯状）的图形边界


走样现象（ 2 / 3 ）

图形细节失真

#### 面积变大


走样现象（ 3 / 3 ）

狭小图形的遗失与动态图形

的闪烁


####  1. 从硬件角度提高分辨率

- 高分辨率显示器

#### 显示器点距减少一倍

#### 帧缓存容量增加到原来的 4 倍

#### 输带宽提高 4 倍

#### 扫描转换花 4 倍时间

#### 代价高

图形反走样技术（ **Antialiasing** ）


图形反走样技术（ **Antialiasing** ）

####  2. 从软件角度提高分辨率

- 高分辨率计算，低分辨率显示
- 像素细分技术，相当于后置滤波

```
1
1
```
```
1
1
```
#### 算术

#### 平均

```
1 2
2
1
```
```
4
2
```
```
1
2
1
```
#### 加权

#### 平均

#### 只能减轻，不能消除


 3. 区域采样技术

- 改变边或直线的外观，模糊淡化阶梯
- 相当于图像的前置滤波

#### 直线有宽度 抽象点 有限区域

图形反走样技术（ **Antialiasing** ）


#### 8 级灰度

```
0 ≤面积≤ 1 / 8 7 / 8 ≤面积≤ 1
```
#### 根据相交的面积值决定像素显示的亮度级别

图形反走样技术（ **Antialiasing** ）


#### 根据相交的面积值决定像素显示的亮度级别

图形反走样技术（ **Antialiasing** ）

```
e
P 1
```
```
P 2
```
```
P
�� ��+ 1
```
#### �� ��+ 1

#### � =

#### �� + ��+ 1

#### 2

#### =

#### �� + �(�� + 1 )

#### 2

#### = �� +

#### �

#### 2

#### = � +

#### �

#### 2

#### � = ��


**Q & A**


